<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>APA â€” WebGPU åŠ é€Ÿè‡ªåŠ¨æ³Šè½¦ä»¿çœŸ Â· è¿›åŒ–ä¼˜åŒ– Â· 12USS</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;600;700&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#070a0e;--pn:#0c0f16;--cd:#11151e;--bd:#1a1f2e;--tx:#c0c7d2;--dm:#5c6370;
--ac:#38bdf8;--a2:#818cf8;--wn:#f59e0b;--er:#ef4444;--ok:#34d399;--gp:#a855f7;--ev:#ec4899}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--tx);
font-family:'Noto Sans SC',system-ui,sans-serif;font-size:13px}
#app{display:grid;grid-template-columns:310px 1fr;height:100vh}
#pn{background:var(--pn);border-right:1px solid var(--bd);display:flex;flex-direction:column;overflow:hidden}
#ph{padding:14px 16px 10px;border-bottom:1px solid var(--bd)}
#ph h1{font-family:'JetBrains Mono',monospace;font-size:13px;font-weight:700;color:var(--ac);display:flex;align-items:center;gap:8px}
#ph h1 span{font-size:10px;color:var(--dm);font-weight:400}
#ps{flex:1;overflow-y:auto;padding:8px 12px 20px}
#ps::-webkit-scrollbar{width:3px}
#ps::-webkit-scrollbar-thumb{background:var(--bd);border-radius:2px}
.S{margin-bottom:10px}.ST{font-family:'JetBrains Mono',monospace;font-size:9px;font-weight:600;
text-transform:uppercase;letter-spacing:1.2px;color:var(--dm);margin-bottom:6px;padding-left:2px}
.C{background:var(--cd);border:1px solid var(--bd);border-radius:8px;padding:8px 10px;margin-bottom:6px}
.TB{display:flex;flex-wrap:wrap;gap:4px}
.TB button{font-family:'JetBrains Mono',monospace;font-size:9px;background:var(--cd);color:var(--dm);
border:1px solid var(--bd);border-radius:5px;padding:5px 8px;cursor:pointer;transition:.15s;white-space:nowrap}
.TB button:hover{color:var(--tx);border-color:#2a3040}
.TB button.active{color:var(--ac);border-color:var(--ac);box-shadow:0 0 12px rgba(56,189,248,.12)}
.CR{display:flex;gap:4px;margin-top:5px}
.CR button{flex:1;font-family:'JetBrains Mono',monospace;font-size:10px;font-weight:600;padding:7px 4px;
border-radius:6px;border:1px solid var(--bd);background:var(--cd);color:var(--tx);cursor:pointer;transition:.15s}
.CR button.running{background:var(--ac);color:#080a0f;border-color:var(--ac)}
.CR button:hover{border-color:var(--ac)}
.P{display:flex;align-items:center;gap:5px;margin:3px 0}
.P label{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--dm);min-width:68px}
.P input{flex:1;background:var(--bg);color:var(--tx);border:1px solid var(--bd);border-radius:4px;
padding:3px 5px;font-family:'JetBrains Mono',monospace;font-size:10px;width:42px;text-align:right}
.P .U{font-family:'JetBrains Mono',monospace;font-size:8px;color:var(--dm);min-width:14px}
.MG{display:grid;grid-template-columns:1fr 1fr;gap:3px 10px}
.MR{display:flex;justify-content:space-between;align-items:center;font-size:10px}
.MR .ML{color:var(--dm);font-size:9px}.MR .MV{font-family:'JetBrains Mono',monospace;font-weight:600;font-size:10px}
.MV.ok{color:var(--ok)}.MV.er{color:var(--er)}.MV.gp{color:var(--gp)}.MV.ev{color:var(--ev)}
#GS{display:flex;align-items:center;gap:6px;padding:6px 10px;border-radius:6px;font-size:9px;
font-family:'JetBrains Mono',monospace;margin-bottom:6px;border:1px solid var(--bd);background:var(--cd)}
#GS .dt{width:7px;height:7px;border-radius:50%}
#GS.on .dt{background:var(--gp);box-shadow:0 0 6px var(--gp)}
#GS.off .dt{background:var(--er)}
#GS.on{border-color:rgba(168,85,247,.3)}
.TG{display:flex;align-items:center;gap:7px;font-size:10px;margin:4px 0}
.TG label{color:var(--dm);font-family:'JetBrains Mono',monospace;font-size:9px}
.tg{width:30px;height:16px;background:var(--bd);border-radius:8px;cursor:pointer;position:relative;transition:.2s}
.tg.on{background:var(--gp)}.tg::after{content:'';position:absolute;top:2px;left:2px;width:12px;height:12px;
background:#fff;border-radius:50%;transition:.2s}.tg.on::after{left:16px}
.EB{height:4px;background:var(--bd);border-radius:2px;overflow:hidden;margin:4px 0}
.EF{height:100%;background:linear-gradient(90deg,var(--ev),var(--a2));border-radius:2px;transition:width .3s}
.EL{max-height:72px;overflow-y:auto;font-family:'JetBrains Mono',monospace;font-size:8px;color:var(--dm);
line-height:1.6;margin-top:4px;background:var(--bg);border-radius:4px;padding:4px 6px}
.IR{display:flex;gap:4px;margin-top:4px}
.IR button{flex:1;font-family:'JetBrains Mono',monospace;font-size:8px;padding:4px;border-radius:5px;
border:1px solid var(--bd);background:var(--cd);color:var(--dm);cursor:pointer}
.IR button:hover{color:var(--tx);border-color:var(--ac)}
.eb{border-color:rgba(236,72,153,.3)!important;color:var(--ev)!important}
.eb:hover{border-color:var(--ev)!important;background:rgba(236,72,153,.08)!important}
#cw{position:relative;overflow:hidden;background:#050810}
canvas{display:block;width:100%;height:100%}
#hud{position:absolute;top:10px;left:14px;font-family:'JetBrains Mono',monospace;
background:rgba(11,14,20,.88);border:1px solid var(--bd);border-radius:7px;padding:7px 12px;
backdrop-filter:blur(8px);font-size:9px;line-height:1.8}
#hud .lb{color:var(--dm)}#hud .vl{color:var(--ac);font-weight:600}
#SB{position:absolute;top:10px;right:14px;font-family:'JetBrains Mono',monospace;font-size:10px;
font-weight:700;letter-spacing:1px;padding:5px 12px;border-radius:5px;
background:rgba(11,14,20,.88);border:1px solid var(--bd);backdrop-filter:blur(8px)}
#SB.idle{color:var(--dm)}#SB.planning{color:var(--ac)}
#SB.success{color:var(--ok);border-color:var(--ok)}#SB.nopath{color:var(--er);border-color:var(--er)}#SB.aligning{color:var(--wn);border-color:var(--wn)}#SB.avoiding{color:var(--gp);border-color:var(--gp)}
#SB.emergency{color:var(--er);border-color:var(--er);box-shadow:0 0 10px rgba(239,68,68,.25)}
#PS{position:absolute;top:38px;right:14px;font-family:'JetBrains Mono',monospace;font-size:9px;
padding:5px 10px;border-radius:5px;background:rgba(11,14,20,.88);border:1px solid var(--bd);
backdrop-filter:blur(8px);display:none;line-height:1.7}
</style>
</head>
<body>
<div id="app">
<div id="pn">
 <div id="ph"><h1>â—ˆ APA <span>WebGPU Â· è¿›åŒ– Â· 12USS+LiDAR</span></h1></div>
 <div id="ps">
  <div id="GS" class="off"><div class="dt"></div><span id="GL">åˆå§‹åŒ–â€¦</span><span id="GD" style="margin-left:auto;font-size:8px;color:var(--dm)"></span></div>
  <div class="S"><div class="ST">å·¥å…·</div><div class="C"><div class="TB" id="toolbar">
   <button data-mode="select" class="active">âŠ é€‰æ‹©</button><button data-mode="ego">âŠ• è½¦è¾†</button>
   <button data-mode="rect">â–ª çŸ©å½¢</button><button data-mode="circle">â— åœ†å½¢</button>
   <button data-mode="dyn">â— åŠ¨æ€</button><button data-mode="slot">âŠŸ è½¦ä½</button>
  </div></div></div>
  <div class="S"><div class="ST">ä»¿çœŸ</div><div class="C">
   <div class="CR"><button id="btnPlay">â–¶ å¼€å§‹</button><button id="btnStep">â­ å•æ­¥</button><button id="btnReset">â†º é‡ç½®</button></div>
   <div style="font-size:9px;color:var(--dm);margin-top:3px">æ»šè½®ç¼©æ”¾ Â· ç©ºæ ¼+æ‹–æ‹½å¹³ç§» Â· Delåˆ é™¤</div>
  </div></div>
  <div class="S"><div class="ST">ä¼ æ„Ÿå™¨ (LiDAR + 12Ã—USS)</div><div class="C">
   <div class="P"><label>LiDARè·ç¦»</label><input id="iLR" type="number" value="25"><span class="U">m</span></div>
   <div class="P"><label>LiDAR FOV</label><input id="iLF" type="number" value="180"><span class="U">Â°</span></div>
   <div class="P"><label>USSè·ç¦»</label><input id="iUR" type="number" step="0.5" value="5"><span class="U">m</span></div>
   <div class="P"><label>é‡è§„åˆ’</label><input id="iRP" type="number" value="1"><span class="U">æ­¥</span></div>
   <div class="TG"><label>æ˜¾ç¤ºUSSæ‰‡åŒº</label><div id="tUSS" class="tg on"></div></div>
  </div></div>
  <div class="S"><div class="ST">è½¦è¾†</div><div class="C">
   <div class="P"><label>è½¦é•¿</label><input id="iVL" type="number" step="0.1" value="4.6"><span class="U">m</span></div>
   <div class="P"><label>è½¦å®½</label><input id="iVW" type="number" step="0.1" value="1.9"><span class="U">m</span></div>
   <div class="P"><label>è½´è·</label><input id="iWB" type="number" step="0.1" value="2.75"><span class="U">m</span></div>
   <div class="P"><label>å‰æ‚¬</label><input id="iFO" type="number" step="0.05" value="0.95"><span class="U">m</span></div>
   <div class="P"><label>åæ‚¬</label><input id="iRO" type="number" step="0.05" value="0.90"><span class="U">m</span></div>
   <div class="P"><label>æœ€å¤§è½¬è§’</label><input id="iMS" type="number" step="1" value="35"><span class="U">Â°</span></div>
   <div class="P"><label>è†¨èƒ€</label><input id="iIF" type="number" step="0.05" value="0.20"><span class="U">m</span></div>
   <div class="P"><label>dt</label><input id="iDT" type="number" step="0.05" value="0.20"><span class="U">s</span></div>
  </div></div>
  <div class="S"><div class="ST">è§„åˆ’å™¨</div><div class="C">
   <div class="P"><label>æœ€å¤§æ—¶é—´</label><input id="iPT" type="number" value="25"><span class="U">s</span></div>
   <div class="P"><label>è§„åˆ’é€Ÿåº¦</label><input id="iPV" type="number" step="0.5" value="1.5"><span class="U">m/s</span></div>
   <div class="P"><label>ç½‘æ ¼ç²¾åº¦</label><input id="iGR" type="number" step="0.05" value="0.50"><span class="U">m</span></div>
   <div class="TG"><label>æ˜¾ç¤ºC-Space</label><div id="tCS" class="tg"></div></div>
  </div></div>
  <div class="S"><div class="ST">æ³Šè½¦éªŒè¯</div><div class="C">
   <div class="P"><label>èˆªå‘å®¹å·®</label><input id="iYT" type="number" step="0.5" value="2.0"><span class="U">Â°</span></div>
   <div class="P"><label>æ¨ªå‘å®¹å·®</label><input id="iLT" type="number" step="0.01" value="0.15"><span class="U">m</span></div>
   <div class="P"><label>å‹çº¿å®¹å·®</label><input id="iBT" type="number" step="0.01" value="0.05"><span class="U">m</span></div>
  </div></div>
  <div class="S"><div class="ST">ğŸ§  ç¥ç»è¿›åŒ–æ§åˆ¶å™¨</div><div class="C">
   <div class="P"><label>ç§ç¾¤</label><input id="eP" type="number" value="50"></div>
   <div class="P"><label>ä»£æ•°</label><input id="eG" type="number" value="30"></div>
   <div style="font-size:9px;color:var(--dm);margin:3px 0 5px">è¾“å…¥: 12å°„çº¿ + ç›®æ ‡dx/dy/dYaw + é€Ÿåº¦ Â· è¾“å‡º: è½¬å‘/æ²¹é—¨/æ¡£ä½</div>
   <div class="EB"><div class="EF" id="evoBar" style="width:0%"></div></div>
   <div class="CR"><button class="eb" id="btnEvo">âš¡ å¯åŠ¨è®­ç»ƒ</button><button id="btnApply" style="border-color:rgba(52,211,153,.3);color:var(--ok)">âœ“ åº”ç”¨æœ€ä¼˜ç­–ç•¥</button></div>
   <div class="EL" id="evoLog"></div>
  </div></div>
  <div class="S"><div class="ST">æŒ‡æ ‡</div><div class="C"><div class="MG">
   <div class="MR"><span class="ML">æ—¶é—´</span><span class="MV" id="mT">0.0s</span></div>
   <div class="MR"><span class="ML">çŠ¶æ€</span><span class="MV" id="mSt">ç©ºé—²</span></div>
   <div class="MR"><span class="ML">æ¢æŒ¡</span><span class="MV" id="mG">0</span></div>
   <div class="MR"><span class="ML">è·ç¦»</span><span class="MV" id="mD">0.0m</span></div>
   <div class="MR"><span class="ML">A*</span><span class="MV" id="mPl">â€”</span></div>
   <div class="MR"><span class="ML">GPUç½‘æ ¼</span><span class="MV gp" id="mGd">â€”</span></div>
   <div class="MR"><span class="ML">ç¢°æ’</span><span class="MV ok" id="mCo">æ— </span></div>
   <div class="MR"><span class="ML">æ³Šè½¦è¯„åˆ†</span><span class="MV ev" id="mPS">â€”</span></div>
  </div></div></div>
  <div class="S"><div class="ST">åœºæ™¯é¢„è®¾</div><div class="C">
   <div class="IR"><button id="btnP1">â˜… ä¾§æ–¹ä½</button><button id="btnP2">â˜… å‚ç›´ä½</button><button id="btnP3">â˜… æ–œå‘ä½</button></div>
   <div class="IR"><button id="btnP4">â˜… å‹åŠ›æµ‹è¯•</button><button id="btnExp">ğŸ“‹ å¯¼å‡º</button><button id="btnImp">ğŸ“¥ å¯¼å…¥</button></div>
   <div class="IR"><button id="btnYawL">â†º è½¦å¤´å·¦è½¬</button><button id="btnYawR">â†» è½¦å¤´å³è½¬</button></div>
  </div></div>
 </div>
</div>
<div id="cw">
 <canvas id="canvas"></canvas>
 <div id="hud"><span class="lb">æ¨¡å¼</span> <span class="vl" id="hudM">SELECT</span><br/>
  <span class="lb">t=</span><span class="vl" id="hudT">0.00</span> <span class="lb">æ­¥</span><span class="vl" id="hudS">0</span></div>
 <div id="SB" class="idle">ç©ºé—²</div>
 <div id="PS"></div>
</div>
</div>
<script>

// â•â•â•â•â•â•â•â•â•â•â• UTILS â•â•â•â•â•â•â•â•â•â•â•
const PI=Math.PI,TAU=2*PI,deg2rad=d=>d*PI/180,rad2deg=r=>r*180/PI;
const clamp=(v,a,b)=>v<a?a:v>b?b:v,hypot=(a,b)=>Math.sqrt(a*a+b*b);
function wrapPi(a){a%=TAU;if(a>PI)a-=TAU;if(a<=-PI)a+=TAU;return a;}
let _uid=0;function uid(){return'o'+(++_uid);}
const kmh2ms=v=>v/3.6;
const MOVING_KIND_SPEED={è¡Œäºº:kmh2ms(5),è‡ªè¡Œè½¦:kmh2ms(20),å¯¹å‘è½¦:kmh2ms(15)};

// â•â•â•â•â•â•â•â•â•â•â• WEBGPU C-SPACE â•â•â•â•â•â•â•â•â•â•â•
const GPU={device:null,ready:false,pipeline:null,bgl:null,MAX_OBS:48,
  xMin:-15,yMin:-10,xMax:35,yMax:25,step:0.25,nYaw:36,
  nX:0,nY:0,total:0,pBuf:null,oBuf:null,outB:null,rdB:null,grid:null,ms:0};

const WGSL=`
struct P{xMin:f32,yMin:f32,step:f32,nX:u32,nY:u32,nYaw:u32,eL:f32,eW:f32,inf:f32,nObs:u32,_0:f32,_1:f32};
struct O{kind:f32,x:f32,y:f32,yaw:f32,w:f32,h:f32,r:f32,pad:f32};
@group(0)@binding(0) var<uniform> p:P;
@group(0)@binding(1) var<storage,read> obs:array<O>;
@group(0)@binding(2) var<storage,read_write> g:array<u32>;
fn cn(cx:f32,cy:f32,a:f32,hw:f32,hh:f32,i:u32)->vec2f{
  let c=cos(a);let s=sin(a);
  switch(i){case 0u:{return vec2f(cx+c*hw-s*hh,cy+s*hw+c*hh);}
  case 1u:{return vec2f(cx+c*hw+s*hh,cy+s*hw-c*hh);}
  case 2u:{return vec2f(cx-c*hw+s*hh,cy-s*hw-c*hh);}
  default:{return vec2f(cx-c*hw-s*hh,cy-s*hw+c*hh);}}
}
fn pj(a:vec2f,b:vec2f,c:vec2f,d:vec2f,ax:vec2f)->vec2f{
  let v0=dot(a,ax);let v1=dot(b,ax);let v2=dot(c,ax);let v3=dot(d,ax);
  return vec2f(min(min(v0,v1),min(v2,v3)),max(max(v0,v1),max(v2,v3)));
}
fn satRR(x1:f32,y1:f32,a1:f32,hw1:f32,hh1:f32,x2:f32,y2:f32,a2:f32,hw2:f32,hh2:f32)->bool{
  let e0=cn(x1,y1,a1,hw1,hh1,0u);let e1=cn(x1,y1,a1,hw1,hh1,1u);
  let e2=cn(x1,y1,a1,hw1,hh1,2u);let e3=cn(x1,y1,a1,hw1,hh1,3u);
  let o0=cn(x2,y2,a2,hw2,hh2,0u);let o1=cn(x2,y2,a2,hw2,hh2,1u);
  let o2=cn(x2,y2,a2,hw2,hh2,2u);let o3=cn(x2,y2,a2,hw2,hh2,3u);
  let ax0=vec2f(e1.y-e0.y,e0.x-e1.x);let ax1=vec2f(e2.y-e1.y,e1.x-e2.x);
  let ax2=vec2f(o1.y-o0.y,o0.x-o1.x);let ax3=vec2f(o2.y-o1.y,o1.x-o2.x);
  var pa=pj(e0,e1,e2,e3,ax0);var pb=pj(o0,o1,o2,o3,ax0);if(pa.y<pb.x||pb.y<pa.x){return false;}
  pa=pj(e0,e1,e2,e3,ax1);pb=pj(o0,o1,o2,o3,ax1);if(pa.y<pb.x||pb.y<pa.x){return false;}
  pa=pj(e0,e1,e2,e3,ax2);pb=pj(o0,o1,o2,o3,ax2);if(pa.y<pb.x||pb.y<pa.x){return false;}
  pa=pj(e0,e1,e2,e3,ax3);pb=pj(o0,o1,o2,o3,ax3);if(pa.y<pb.x||pb.y<pa.x){return false;}
  return true;
}
fn rcCol(rx:f32,ry:f32,ra:f32,hw:f32,hh:f32,cx:f32,cy:f32,cr:f32)->bool{
  let dx=cx-rx;let dy=cy-ry;let c=cos(-ra);let s=sin(-ra);
  let lx=c*dx-s*dy;let ly=s*dx+c*dy;
  let nx=clamp(lx,-hw,hw);let ny=clamp(ly,-hh,hh);
  return(lx-nx)*(lx-nx)+(ly-ny)*(ly-ny)<=cr*cr;
}
@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid:vec3u){
  let idx=gid.x;if(idx>=p.nX*p.nY*p.nYaw){return;}
  let iy_aw=idx%p.nYaw;let tmp=idx/p.nYaw;let iy=tmp%p.nY;let ix=tmp/p.nY;
  let x=p.xMin+f32(ix)*p.step;let y=p.yMin+f32(iy)*p.step;
  let yaw=f32(iy_aw)*6.283185307/f32(p.nYaw);
  let eHW=(p.eL+2.0*p.inf)/2.0;let eHH=(p.eW+2.0*p.inf)/2.0;
  var col=false;
  for(var i=0u;i<p.nObs;i++){let ob=obs[i];
    if(ob.kind<0.5){if(satRR(x,y,yaw,eHW,eHH,ob.x,ob.y,ob.yaw,ob.w/2.0,ob.h/2.0)){col=true;break;}}
    else{if(rcCol(x,y,yaw,eHW,eHH,ob.x,ob.y,ob.r)){col=true;break;}}
  }g[idx]=select(0u,1u,col);
}`;

async function initGPU(){
  GPU.nX=Math.ceil((GPU.xMax-GPU.xMin)/GPU.step);
  GPU.nY=Math.ceil((GPU.yMax-GPU.yMin)/GPU.step);
  GPU.total=GPU.nX*GPU.nY*GPU.nYaw;
  GPU.grid=new Uint32Array(GPU.total);
  const el=document.getElementById('GS'),lb=document.getElementById('GL'),dt=document.getElementById('GD');
  dt.textContent=`${(GPU.total/1000)|0}K cells`;
  document.getElementById('mGd').textContent='â€”';
  if(!navigator.gpu){lb.textContent='WebGPUä¸å¯ç”¨ (CPUå›é€€)';document.getElementById('mGd').textContent='CPU';return;}
  try{
    GPU.adapter=await navigator.gpu.requestAdapter();
    if(!GPU.adapter){lb.textContent='æ— GPUé€‚é…å™¨ (CPUå›é€€)';document.getElementById('mGd').textContent='CPU';return;}
    GPU.device=await GPU.adapter.requestDevice();
    const md=GPU.device.createShaderModule({code:WGSL});
    GPU.bgl=GPU.device.createBindGroupLayout({entries:[
      {binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:'uniform'}},
      {binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:'read-only-storage'}},
      {binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:'storage'}}]});
    GPU.pipeline=await GPU.device.createComputePipelineAsync({
      layout:GPU.device.createPipelineLayout({bindGroupLayouts:[GPU.bgl]}),
      compute:{module:md,entryPoint:'main'}});
    GPU.pBuf=GPU.device.createBuffer({size:48,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});
    GPU.oBuf=GPU.device.createBuffer({size:GPU.MAX_OBS*32,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});
    GPU.outB=GPU.device.createBuffer({size:GPU.total*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC});
    GPU.rdB=GPU.device.createBuffer({size:GPU.total*4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});
    GPU.ready=true;
    let info={};
    if(typeof GPU.adapter.requestAdapterInfo==='function')info=await GPU.adapter.requestAdapterInfo().catch(()=>({}));
    el.className='on';lb.textContent=info.description||'WebGPU å·²æ¿€æ´»';
    dt.textContent=`${(GPU.total/1000)|0}K`;
    document.getElementById('mGd').textContent='GPU';
  }catch(e){console.warn(e);GPU.ready=false;el.className='off';lb.textContent='GPUåˆå§‹åŒ–å¤±è´¥ (CPUå›é€€)';document.getElementById('mGd').textContent='CPU';}
}

async function computeGrid(obs,vp){
  const t0=performance.now();
  if(GPU.ready){
    try{
      const n=Math.min(obs.length,GPU.MAX_OBS);
      const pm=new Float32Array(12);
      pm[0]=GPU.xMin;pm[1]=GPU.yMin;pm[2]=GPU.step;
      const dv=new DataView(pm.buffer);
      dv.setUint32(12,GPU.nX,true);dv.setUint32(16,GPU.nY,true);dv.setUint32(20,GPU.nYaw,true);
      pm[6]=vp.length;pm[7]=vp.width;pm[8]=vp.inflation;dv.setUint32(36,n,true);
      GPU.device.queue.writeBuffer(GPU.pBuf,0,pm);
      const od=new Float32Array(GPU.MAX_OBS*8);
      for(let i=0;i<n;i++){const o=obs[i],j=i*8;
        od[j]=o.shape==='circle'?1:0;od[j+1]=o.x;od[j+2]=o.y;od[j+3]=o.yaw||0;
        od[j+4]=o.w||0;od[j+5]=o.h||0;od[j+6]=o.r||0;}
      GPU.device.queue.writeBuffer(GPU.oBuf,0,od);
      const bg=GPU.device.createBindGroup({layout:GPU.bgl,entries:[
        {binding:0,resource:{buffer:GPU.pBuf}},{binding:1,resource:{buffer:GPU.oBuf}},
        {binding:2,resource:{buffer:GPU.outB}}]});
      const enc=GPU.device.createCommandEncoder();
      const ps=enc.beginComputePass();ps.setPipeline(GPU.pipeline);ps.setBindGroup(0,bg);
      ps.dispatchWorkgroups(Math.ceil(GPU.total/256));ps.end();
      enc.copyBufferToBuffer(GPU.outB,0,GPU.rdB,0,GPU.total*4);
      GPU.device.queue.submit([enc.finish()]);
      await GPU.rdB.mapAsync(GPUMapMode.READ);
      GPU.grid=new Uint32Array(GPU.rdB.getMappedRange().slice(0));
      GPU.rdB.unmap();
    }catch(e){
      console.warn('WebGPU compute failed, fallback to CPU',e);
      GPU.ready=false;
      document.getElementById('GL').textContent='WebGPUè®¡ç®—å¤±è´¥ (CPUå›é€€)';
      document.getElementById('mGd').textContent='CPU';
    }
  }

  if(!GPU.ready){
    // CPU fallback
    const eHW=(vp.length+2*vp.inflation)/2,eHH=(vp.width+2*vp.inflation)/2;
    for(let idx=0;idx<GPU.total;idx++){
      const iw=idx%GPU.nYaw,tmp=(idx/GPU.nYaw)|0,iy=tmp%GPU.nY,ix=(tmp/GPU.nY)|0;
      const x=GPU.xMin+ix*GPU.step,y=GPU.yMin+iy*GPU.step,yaw=iw*TAU/GPU.nYaw;
      let c=false;
      for(const o of obs){
        if(o.shape==='circle'){if(cpuRC(x,y,yaw,eHW*2,eHH*2,o.x,o.y,o.r||0.3)){c=true;break;}}
        else{if(cpuSAT(x,y,yaw,eHW*2,eHH*2,o.x,o.y,o.yaw||0,o.w||1,o.h||1)){c=true;break;}}
      }GPU.grid[idx]=c?1:0;
    }
  }
  GPU.ms=performance.now()-t0;
}

function gridLK(x,y,yaw){
  const ix=Math.round((x-GPU.xMin)/GPU.step),iy=Math.round((y-GPU.yMin)/GPU.step);
  let iw=Math.round((((yaw%TAU)+TAU)%TAU)/(TAU/GPU.nYaw));
  iw=((iw%GPU.nYaw)+GPU.nYaw)%GPU.nYaw;
  if(ix<0||ix>=GPU.nX||iy<0||iy>=GPU.nY)return 1;
  return GPU.grid[ix*GPU.nY*GPU.nYaw+iy*GPU.nYaw+iw];
}

// â•â•â•â•â•â•â•â•â•â•â• CPU COLLISION â•â•â•â•â•â•â•â•â•â•â•
function cpuRC(rx,ry,ra,rw,rh,cx,cy,cr){
  const dx=cx-rx,dy=cy-ry,c=Math.cos(-ra),s=Math.sin(-ra);
  const lx=c*dx-s*dy,ly=s*dx+c*dy;
  const nx=clamp(lx,-rw/2,rw/2),ny=clamp(ly,-rh/2,rh/2);
  return(lx-nx)**2+(ly-ny)**2<=cr*cr;
}
function cpuSAT(x1,y1,a1,w1,h1,x2,y2,a2,w2,h2){
  function gc(cx,cy,a,w,h){const c=Math.cos(a),s=Math.sin(a),hw=w/2,hh=h/2;
    return[{x:cx+c*hw-s*hh,y:cy+s*hw+c*hh},{x:cx+c*hw+s*hh,y:cy+s*hw-c*hh},
           {x:cx-c*hw+s*hh,y:cy-s*hw-c*hh},{x:cx-c*hw-s*hh,y:cy-s*hw+c*hh}];}
  function pr(cs,ax,ay){let mn=1e9,mx=-1e9;for(const p of cs){const d=p.x*ax+p.y*ay;if(d<mn)mn=d;if(d>mx)mx=d;}return[mn,mx];}
  const c1=gc(x1,y1,a1,w1,h1),c2=gc(x2,y2,a2,w2,h2);
  for(const cs of[c1,c2])for(let i=0;i<2;i++){
    const j=(i+1)%4,ax=cs[j].y-cs[i].y,ay=cs[i].x-cs[j].x;
    const[n1,x1p]=pr(c1,ax,ay),[n2,x2p]=pr(c2,ax,ay);
    if(x1p<n2||x2p<n1)return false;}
  return true;
}
function egoCol(pose,vp,ob){
  const ew=vp.length+2*vp.inflation,eh=vp.width+2*vp.inflation;
  if(ob.shape==='circle')return cpuRC(pose.x,pose.y,pose.yaw,ew,eh,ob.x,ob.y,ob.r||0.3);
  return cpuSAT(pose.x,pose.y,pose.yaw,ew,eh,ob.x,ob.y,ob.yaw||0,ob.w||1,ob.h||1);
}

// â•â•â•â•â•â•â•â•â•â•â• BICYCLE MODEL â•â•â•â•â•â•â•â•â•â•â•
function bicStep(st,steer,a,vp){
  const dt=vp.dt;a=clamp(a,-vp.maxA,vp.maxA);
  let v=clamp(st.v+a*dt,-vp.maxV,vp.maxV);
  if(st.gear===1)v=Math.max(0,v);else v=Math.min(0,v);
  const yr=(v/vp.wheelbase)*Math.tan(steer);
  return{x:st.x+v*Math.cos(st.yaw)*dt,y:st.y+v*Math.sin(st.yaw)*dt,
    yaw:wrapPi(st.yaw+yr*dt),v,gear:st.gear};
}

// â•â•â•â•â•â•â•â•â•â•â• 12-USS SENSOR LAYOUT â•â•â•â•â•â•â•â•â•â•â•
// Industry standard: 4 front, 4 rear, 2 left side, 2 right side
// Positions relative to vehicle center, angles relative to vehicle heading
function getUSSLayout(vp){
  const L=vp.length,W=vp.width,fo=vp.frontOverhang,ro=vp.rearOverhang;
  const wb=vp.wheelbase;
  // Front bumper center-x = rearAxle + wheelbase + frontOverhang - L/2
  // Actually simpler: front bumper at +L/2, rear at -L/2
  const fBump=L/2, rBump=-L/2;
  return[
    // Front 4: left-corner, left-center, right-center, right-corner
    {x:fBump,y: W*0.42, ang: deg2rad(60),  fov:deg2rad(60), name:'FL'},
    {x:fBump,y: W*0.15, ang: deg2rad(10),  fov:deg2rad(60), name:'FCL'},
    {x:fBump,y:-W*0.15, ang: deg2rad(-10), fov:deg2rad(60), name:'FCR'},
    {x:fBump,y:-W*0.42, ang: deg2rad(-60), fov:deg2rad(60), name:'FR'},
    // Rear 4: left-corner, left-center, right-center, right-corner
    {x:rBump,y: W*0.42, ang: deg2rad(120), fov:deg2rad(60), name:'RL'},
    {x:rBump,y: W*0.15, ang: deg2rad(170), fov:deg2rad(60), name:'RCL'},
    {x:rBump,y:-W*0.15, ang: deg2rad(-170),fov:deg2rad(60), name:'RCR'},
    {x:rBump,y:-W*0.42, ang: deg2rad(-120),fov:deg2rad(60), name:'RR'},
    // Side 2+2: at B-pillar and C-pillar positions
    {x: wb*0.15, y: W/2, ang: deg2rad(90),  fov:deg2rad(70), name:'SFL'},
    {x:-wb*0.15, y: W/2, ang: deg2rad(90),  fov:deg2rad(70), name:'SRL'},
    {x: wb*0.15, y:-W/2, ang: deg2rad(-90), fov:deg2rad(70), name:'SFR'},
    {x:-wb*0.15, y:-W/2, ang: deg2rad(-90), fov:deg2rad(70), name:'SRR'},
  ];
}

function getPerceivedObs(){
  const e=scene.ego, vp=cfg.vehicle;
  const lidarRange=cfg.sensor.lidarRange, lidarFov=deg2rad(cfg.sensor.lidarFov);
  const ussRange=cfg.sensor.ussRange;
  const cosY=Math.cos(e.yaw),sinY=Math.sin(e.yaw);
  const out=[];const seen=new Set();

  for(const ob of scene.obstacles){
    const dx=ob.x-e.x,dy=ob.y-e.y,d=hypot(dx,dy);
    let detected=false;

    // LiDAR check (front-mounted)
    if(d<=lidarRange){
      const ang=wrapPi(Math.atan2(dy,dx)-e.yaw);
      if(Math.abs(ang)<=lidarFov/2) detected=true;
    }

    // USS check - any of 12 sensors
    if(!detected && d<=ussRange+3){
      const ussL=getUSSLayout(vp);
      for(const u of ussL){
        // Transform USS world position
        const ux=e.x+cosY*u.x-sinY*u.y;
        const uy=e.y+sinY*u.x+cosY*u.y;
        const uAng=e.yaw+u.ang;
        const odx=ob.x-ux,ody=ob.y-uy;
        const od=hypot(odx,ody);
        if(od<=ussRange){
          const oAng=wrapPi(Math.atan2(ody,odx)-uAng);
          if(Math.abs(oAng)<=u.fov/2){detected=true;break;}
        }
      }
    }

    if(detected && !seen.has(ob.id)){
      seen.add(ob.id);
      // Add noise for realism
      out.push({...ob,x:ob.x+(Math.random()-.5)*.04,y:ob.y+(Math.random()-.5)*.04});
    }
  }
  return out;
}

// â•â•â•â•â•â•â•â•â•â•â• PARKING VALIDATION â•â•â•â•â•â•â•â•â•â•â•

function getEvalGoalForPose(slot,egoPose){
  const base=slot.goal;
  if(!egoPose)return base;
  const altYaw=wrapPi(base.yaw+PI);
  const dBase=Math.abs(wrapPi(egoPose.yaw-base.yaw));
  const dAlt=Math.abs(wrapPi(egoPose.yaw-altYaw));
  return dAlt<dBase?{...base,yaw:altYaw}:base;
}

// Returns {pass, score, yawErr, latErr, minLineGap, details}
function validateParking(ego,slot,vp){
  const goal=getEvalGoalForPose(slot,ego);
  const poly=slot.poly;

  // 1) Yaw alignment error (how "straight" is the car relative to slot)
  const yawErr=Math.abs(wrapPi(ego.yaw-goal.yaw));
  const yawTol=deg2rad(+document.getElementById('iYT').value||2);

  // 2) Lateral offset (perpendicular distance from slot centerline)
  // Slot centerline is the line along the goal's heading through the slot center
  const slotCx=poly.reduce((s,p)=>s+p.x,0)/poly.length;
  const slotCy=poly.reduce((s,p)=>s+p.y,0)/poly.length;
  const gcos=Math.cos(goal.yaw),gsin=Math.sin(goal.yaw);
  // Project ego center onto slot perpendicular axis
  const dx=ego.x-slotCx,dy=ego.y-slotCy;
  const latErr=Math.abs(-gsin*dx+gcos*dy);
  const latTol=+document.getElementById('iLT').value||0.15;

  // 3) Line crossing check - all 4 corners of ego must be inside slot polygon
  const egoCorners=getEgoCorners(ego,vp);
  let minLineGap=Infinity;
  let insideAll=true;
  for(const c of egoCorners){
    const d=pointToPolyDist(c,poly);
    minLineGap=Math.min(minLineGap,d);
    if(d<0)insideAll=false; // negative means outside
  }
  const lineTol=+document.getElementById('iBT').value||0.05;
  const linePass=minLineGap>=-lineTol;

  const yawPass=yawErr<=yawTol;
  const latPass=latErr<=latTol;
  const pass=yawPass&&latPass&&linePass;

  // Score: 0~100, higher is better
  const yawScore=Math.max(0,100-rad2deg(yawErr)*20);
  const latScore=Math.max(0,100-latErr*200);
  const lineScore=Math.max(0,100-Math.max(0,-minLineGap)*500);
  const score=(yawScore*0.3+latScore*0.3+lineScore*0.4);

  return{pass,score,yawErr:rad2deg(yawErr),latErr,minLineGap,
    yawPass,latPass,linePass,
    details:`èˆªå‘${rad2deg(yawErr).toFixed(1)}Â° æ¨ªå${(latErr*100).toFixed(0)}cm çº¿è·${(minLineGap*100).toFixed(0)}cm`};
}

function getEgoCorners(ego,vp){
  const hw=vp.length/2,hh=vp.width/2;
  const c=Math.cos(ego.yaw),s=Math.sin(ego.yaw);
  return[
    {x:ego.x+c*hw-s*hh,y:ego.y+s*hw+c*hh},
    {x:ego.x+c*hw+s*hh,y:ego.y+s*hw-c*hh},
    {x:ego.x-c*hw+s*hh,y:ego.y-s*hw-c*hh},
    {x:ego.x-c*hw-s*hh,y:ego.y-s*hw+c*hh},
  ];
}

// Signed distance from point to polygon (positive=inside, negative=outside)
function pointToPolyDist(pt,poly){
  let minD=Infinity;
  const n=poly.length;
  for(let i=0;i<n;i++){
    const a=poly[i],b=poly[(i+1)%n];
    const d=pointToSegDist(pt,a,b);
    if(d<minD)minD=d;
  }
  // Check if inside polygon
  let inside=false;
  for(let i=0,j=n-1;i<n;j=i++){
    const yi=poly[i].y,yj=poly[j].y,xi=poly[i].x,xj=poly[j].x;
    if((yi>pt.y)!==(yj>pt.y)&&pt.x<(xj-xi)*(pt.y-yi)/(yj-yi)+xi)inside=!inside;
  }
  return inside?minD:-minD;
}

function pointToSegDist(p,a,b){
  const dx=b.x-a.x,dy=b.y-a.y;
  const len2=dx*dx+dy*dy;
  if(len2===0)return hypot(p.x-a.x,p.y-a.y);
  let t=((p.x-a.x)*dx+(p.y-a.y)*dy)/len2;
  t=clamp(t,0,1);
  return hypot(p.x-(a.x+t*dx),p.y-(a.y+t*dy));
}

function pointInPoly(pt,poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const yi=poly[i].y,yj=poly[j].y,xi=poly[i].x,xj=poly[j].x;
    if((yi>pt.y)!==(yj>pt.y)&&pt.x<(xj-xi)*(pt.y-yi)/(yj-yi)+xi)inside=!inside;
  }
  return inside;
}


function segCross(a,b,c,d){
  function cr(p,q,r){return (q.x-p.x)*(r.y-p.y)-(q.y-p.y)*(r.x-p.x);}
  const c1=cr(a,b,c),c2=cr(a,b,d),c3=cr(c,d,a),c4=cr(c,d,b);
  const eps=1e-8;
  if(Math.abs(c1)<eps&&Math.abs(c2)<eps&&Math.abs(c3)<eps&&Math.abs(c4)<eps){
    const in1=Math.max(Math.min(a.x,b.x),Math.min(c.x,d.x))<=Math.min(Math.max(a.x,b.x),Math.max(c.x,d.x))+eps;
    const in2=Math.max(Math.min(a.y,b.y),Math.min(c.y,d.y))<=Math.min(Math.max(a.y,b.y),Math.max(c.y,d.y))+eps;
    return in1&&in2;
  }
  return (c1*c2<=eps)&&(c3*c4<=eps);
}

function polyIntersectsPoly(pa,pb){
  for(const p of pa)if(pointInPoly(p,pb))return true;
  for(const p of pb)if(pointInPoly(p,pa))return true;
  for(let i=0;i<pa.length;i++){
    const a0=pa[i],a1=pa[(i+1)%pa.length];
    for(let j=0;j<pb.length;j++){
      const b0=pb[j],b1=pb[(j+1)%pb.length];
      if(segCross(a0,a1,b0,b1))return true;
    }
  }
  return false;
}

function obstacleIntersectsSlot(ob,poly){
  if(ob.shape==='circle'){
    const c={x:ob.x,y:ob.y},r=ob.r||0.3;
    if(pointInPoly(c,poly))return true;
    for(let i=0;i<poly.length;i++){
      if(pointToSegDist(c,poly[i],poly[(i+1)%poly.length])<=r)return true;
    }
    for(const v of poly)if((v.x-c.x)*(v.x-c.x)+(v.y-c.y)*(v.y-c.y)<=r*r)return true;
    return false;
  }
  const rc=getRectCorners(ob.x,ob.y,ob.yaw||0,ob.w||1,ob.h||1);
  return polyIntersectsPoly(rc,poly);
}

function getPlanningObstacles(){
  const poly=scene.slot.poly;
  return scene.obstacles.filter(ob=>!obstacleIntersectsSlot(ob,poly));
}


function cornerRadiusPenalty(steer,vp){
  if(Math.abs(steer)<1e-4)return 0;
  const Rc=Math.abs(vp.wheelbase/Math.tan(steer));
  const corners=[
    {x: vp.length/2,y: vp.width/2},
    {x: vp.length/2,y:-vp.width/2},
    {x:-vp.length/2,y: vp.width/2},
    {x:-vp.length/2,y:-vp.width/2},
  ];
  let minR=Infinity;
  for(const c of corners){
    const r=hypot(c.x,Rc-c.y);
    if(r<minR)minR=r;
  }
  return Math.max(0,(3.8-minR));
}

function slotPoseMetric(ego,slot){
  const g0=slot.goal;
  const g1={...g0,yaw:wrapPi(g0.yaw+PI)};
  const m=(g)=>{
    const dx=ego.x-g.x,dy=ego.y-g.y,c=Math.cos(g.yaw),sg=Math.sin(g.yaw);
    const longErr=Math.abs(c*dx+sg*dy),latErr=Math.abs(-sg*dx+c*dy),yawErr=Math.abs(wrapPi(ego.yaw-g.yaw));
    return 2.8*latErr+2.0*longErr+1.9*yawErr;
  };
  return Math.min(m(g0),m(g1));
}

function forecastShuntMetric(endPose,slot,vp,obs){
  let st={x:endPose.x,y:endPose.y,yaw:endPose.yaw,v:endPose.v||0,gear:endPose.gear||1};
  let collided=false;
  for(let n=0;n<3;n++){
    const g=slot.goal;
    const dx=st.x-g.x,dy=st.y-g.y,c=Math.cos(g.yaw),sg=Math.sin(g.yaw);
    const longErr=c*dx+sg*dy,latErr=-sg*dx+c*dy,yawErr=wrapPi(st.yaw-g.yaw);
    const gear=Math.abs(longErr)>0.1?(longErr>0?-1:1):(Math.abs(yawErr)>deg2rad(4)?(yawErr>0?-1:1):1);
    const steer=clamp(-(2.8*yawErr+1.8*latErr),-vp.maxSteer*0.9,vp.maxSteer*0.9);
    const targetV=0.28*gear;
    const a=clamp((targetV-st.v)/vp.dt,-vp.maxA,vp.maxA);
    st.gear=gear;
    for(let k=0;k<3;k++){
      st=bicStep(st,steer,a,vp);
      for(const ob of (obs||[])){
        const pob={...ob,x:ob.x+(ob.vx||0)*(k+1)*vp.dt,y:ob.y+(ob.vy||0)*(k+1)*vp.dt};
        if(egoCol(st,vp,pob)){collided=true;break;}
      }
      if(collided)break;
    }
    if(collided)break;
  }
  return {metric:slotPoseMetric(st,slot),collided};
}

function evaluatePlannedPath(path,slot,vp,obs){
  if(!path||path.length<2)return {ok:false,score:1e9};
  const end=path[path.length-1];
  const term=slotPoseMetric(end,slot);
  const sh=forecastShuntMetric(end,slot,vp,obs);
  const score=term+0.85*sh.metric+(sh.collided?8:0);
  const ok=!sh.collided&&term<=1.55&&sh.metric<=1.35;
  return {ok,score};
}

// â•â•â•â•â•â•â•â•â•â•â• HYBRID A* (GPU ACCELERATED) â•â•â•â•â•â•â•â•â•â•â•
function planHybridAStar(ego0,goal,vp,pc){
  const dt=vp.dt,SUB=3,maxIt=Math.floor(pc.maxTime/dt);
  const rXY=pc.resXY,rYaw=pc.resYaw||36;
  const stSet=[-vp.maxSteer,-0.5*vp.maxSteer,0,0.5*vp.maxSteer,vp.maxSteer];
  const vPA=pc.vPlan||1.5;
  const W_REV=pc.wRev||2,W_GEAR=pc.wGear||8,W_STEER=pc.wSteer||1,W_LANE=pc.wLane||7,W_CR=pc.wCorner||0.8;
  const laneHardTol=pc.laneHardTol===undefined?Infinity:pc.laneHardTol;
  const goalYawTol=deg2rad(pc.goalYawTol||15),goalPosTol=pc.goalPosTol||0.6;

  function disc(x,y,yaw,g){
    const ix=Math.round(x/rXY),iy=Math.round(y/rXY);
    const ybs=TAU/rYaw;let iw=Math.round(wrapPi(yaw)/ybs);
    iw=((iw%rYaw)+rYaw)%rYaw;
    return`${ix},${iy},${iw},${g}`;
  }
  function h(x,y,yaw){return hypot(goal.x-x,goal.y-y)+0.3*Math.abs(wrapPi(goal.yaw-yaw));}
  function isG(n){return hypot(n.x-goal.x,n.y-goal.y)<goalPosTol&&Math.abs(wrapPi(n.yaw-goal.yaw))<goalYawTol;}

  const nodes=[];const bestG=new Map();const closed=new Set();
  nodes.push({x:ego0.x,y:ego0.y,yaw:ego0.yaw,gear:ego0.gear,it:0,g:0,pi:-1,st:0});
  bestG.set(disc(ego0.x,ego0.y,ego0.yaw,ego0.gear),0);

  // Binary min-heap
  const heap=[];
  function hPush(f,i){heap.push({f,i});let k=heap.length-1;while(k>0){const p=(k-1)>>1;if(heap[p].f<=heap[k].f)break;[heap[p],heap[k]]=[heap[k],heap[p]];k=p;}}
  function hPop(){if(!heap.length)return null;const t=heap[0];const l=heap.pop();if(heap.length){heap[0]=l;let i=0;for(;;){const a=2*i+1,b=a+1;let m=i;if(a<heap.length&&heap[a].f<heap[m].f)m=a;if(b<heap.length&&heap[b].f<heap[m].f)m=b;if(m===i)break;[heap[m],heap[i]]=[heap[i],heap[m]];i=m;}}return t;}

  hPush(h(ego0.x,ego0.y,ego0.yaw),0);
  let exp=0;

  while(true){
    const it=hPop();if(!it)break;
    const ni=it.i,n=nodes[ni];
    const nK=disc(n.x,n.y,n.yaw,n.gear);
    if(closed.has(nK))continue;closed.add(nK);exp++;
    if(exp>60000)break;

    if(isG(n)){
      // Reconstruct coarse path then interpolate substeps
      const cp=[];let ci=ni;while(ci>=0){cp.push(nodes[ci]);ci=nodes[ci].pi;}cp.reverse();
      const fp=[cp[0]];
      for(let i=1;i<cp.length;i++){
        const pv=cp[i-1],steer=cp[i].st,gear=cp[i].gear;
        let cu={x:pv.x,y:pv.y,yaw:pv.yaw,v:vPA*gear,gear};
        for(let s=0;s<SUB;s++){
          cu=bicStep(cu,steer,0,vp);
          fp.push({x:cu.x,y:cu.y,yaw:cu.yaw,gear,it:pv.it+s+1,st:steer});
        }
      }
      return{path:buildSpeedProfile(fp,vp,vPA),expanded:exp};
    }
    if(n.it>=maxIt)continue;

    for(const gear of[1,-1]){
      for(const steer of stSet){
        let cu={x:n.x,y:n.y,yaw:n.yaw,v:vPA*gear,gear};
        let col=false;
        for(let s=0;s<SUB;s++){
          cu=bicStep(cu,steer,0,vp);
          if(gridLK(cu.x,cu.y,cu.yaw)){col=true;break;}
        }
        if(col)continue;
        if(laneOutAmountPose(cu,vp,scene.road)>laneHardTol)continue;
        const k2=disc(cu.x,cu.y,cu.yaw,gear);
        if(closed.has(k2))continue;
        const sl=hypot(cu.x-n.x,cu.y-n.y);
        let cost=sl;
        if(gear===-1)cost+=W_REV*sl;
        if(gear!==n.gear)cost+=W_GEAR;
        cost+=W_STEER*Math.abs(steer-n.st);
        cost+=W_LANE*laneOutAmountPose(cu,vp,scene.road)*sl;
        cost+=W_CR*cornerRadiusPenalty(steer,vp);
        const g2=n.g+cost;
        const old=bestG.get(k2);
        if(old===undefined||g2<old){
          bestG.set(k2,g2);
          const ni2=nodes.length;
          nodes.push({x:cu.x,y:cu.y,yaw:cu.yaw,gear,it:n.it+SUB,g:g2,pi:ni,st:steer});
          hPush(g2+h(cu.x,cu.y,cu.yaw),ni2);
        }
      }
    }
  }
  return null;
}

function buildSpeedProfile(pn,vp,vMax){
  const dt=vp.dt,v=new Array(pn.length).fill(0);
  for(let i=1;i<pn.length;i++){const dv=vp.maxA*dt;v[i]=clamp(vMax*pn[i].gear,v[i-1]-dv,v[i-1]+dv);}
  v[v.length-1]=0;
  for(let i=v.length-2;i>=0;i--){const dv=vp.maxA*dt;if(v[i]>v[i+1]+dv)v[i]=v[i+1]+dv;if(v[i]<v[i+1]-dv)v[i]=v[i+1]-dv;}
  return pn.map((n,i)=>({t:i*dt,x:n.x,y:n.y,yaw:n.yaw,v:v[i],a:i?((v[i]-v[i-1])/dt):0,st:n.st,gear:n.gear}));
}

// â•â•â•â•â•â•â•â•â•â•â• NEUROEVOLUTION TRAINER â•â•â•â•â•â•â•â•â•â•â•
class NeuralNetwork {
  constructor(inputNodes,hiddenNodes,outputNodes){
    this.inputNodes=inputNodes;this.hiddenNodes=hiddenNodes;this.outputNodes=outputNodes;
    this.weightsIH=NeuralNetwork.randArray(this.inputNodes*this.hiddenNodes);
    this.weightsHO=NeuralNetwork.randArray(this.hiddenNodes*this.outputNodes);
    this.biasH=NeuralNetwork.randArray(this.hiddenNodes);
    this.biasO=NeuralNetwork.randArray(this.outputNodes);
  }
  static randArray(n){const arr=new Float32Array(n);for(let i=0;i<n;i++)arr[i]=Math.random()*2-1;return arr;}
  static mutateArray(arr,rate){for(let i=0;i<arr.length;i++)if(Math.random()<rate)arr[i]+=Math.random()*0.4-0.2;}
  predict(inputArray){
    const hidden=new Float32Array(this.hiddenNodes);
    for(let i=0;i<this.hiddenNodes;i++){
      let sum=this.biasH[i];
      for(let j=0;j<this.inputNodes;j++)sum+=inputArray[j]*this.weightsIH[j*this.hiddenNodes+i];
      hidden[i]=Math.tanh(sum);
    }
    const output=new Float32Array(this.outputNodes);
    for(let i=0;i<this.outputNodes;i++){
      let sum=this.biasO[i];
      for(let j=0;j<this.hiddenNodes;j++)sum+=hidden[j]*this.weightsHO[j*this.outputNodes+i];
      output[i]=Math.tanh(sum);
    }
    return output;
  }
  clone(){
    const nn=new NeuralNetwork(this.inputNodes,this.hiddenNodes,this.outputNodes);
    nn.weightsIH.set(this.weightsIH);nn.weightsHO.set(this.weightsHO);nn.biasH.set(this.biasH);nn.biasO.set(this.biasO);
    return nn;
  }
  mutate(rate){
    NeuralNetwork.mutateArray(this.weightsIH,rate);
    NeuralNetwork.mutateArray(this.weightsHO,rate);
    NeuralNetwork.mutateArray(this.biasH,rate);
    NeuralNetwork.mutateArray(this.biasO,rate);
  }
}

function pointInObstacle(px,py,ob){
  if(ob.shape==='circle')return hypot(px-ob.x,py-ob.y)<=(ob.r||0.3);
  const c=Math.cos(-(ob.yaw||0)),s=Math.sin(-(ob.yaw||0));
  const dx=px-ob.x,dy=py-ob.y;
  const lx=c*dx-s*dy,ly=s*dx+c*dy;
  return Math.abs(lx)<=((ob.w||1)/2)&&Math.abs(ly)<=((ob.h||1)/2);
}

class AIAgent {
  constructor(ego0,brain){
    this.brain=brain||new NeuralNetwork(16,12,3);
    this.score=0;this.alive=true;this.stepCount=0;
    this.simEgo={...ego0};
    this.prevDist=Infinity;
    this.path=[{x:ego0.x,y:ego0.y,yaw:ego0.yaw,v:ego0.v,a:0,st:0,gear:ego0.gear,t:0}];
  }
  castRay(pose,angle,obstacles,maxD){
    const step=0.35;
    const dx=Math.cos(angle),dy=Math.sin(angle);
    for(let d=step;d<=maxD;d+=step){
      const px=pose.x+dx*d,py=pose.y+dy*d;
      for(const ob of obstacles){if(pointInObstacle(px,py,ob))return d;}
      if(px<GPU.xMin||px>GPU.xMax||py<GPU.yMin||py>GPU.yMax)return d;
    }
    return maxD;
  }
  getInputs(obstacles,goal,vp){
    const rays=[];const numRays=12;const maxD=Math.max(8,cfg.sensor.lidarRange||20);
    for(let i=0;i<numRays;i++){
      const angle=this.simEgo.yaw+(i/(numRays-1)-0.5)*TAU;
      rays.push(this.castRay(this.simEgo,angle,obstacles,maxD)/maxD);
    }
    const dx=(goal.x-this.simEgo.x)/20;
    const dy=(goal.y-this.simEgo.y)/20;
    const dyaw=Math.sin(goal.yaw-this.simEgo.yaw);
    const v=this.simEgo.v/Math.max(0.1,vp.maxV);
    return [...rays,clamp(dx,-1,1),clamp(dy,-1,1),clamp(dyaw,-1,1),clamp(v,-1,1)];
  }
  update(obstacles,goal,vp,maxSteps){
    if(!this.alive)return;
    const outputs=this.brain.predict(this.getInputs(obstacles,goal,vp));
    this.simEgo.gear=outputs[2]>=0?1:-1;
    const steer=clamp(outputs[0],-1,1)*vp.maxSteer;
    const accel=clamp(outputs[1],-1,1)*vp.maxA;
    this.simEgo=bicStep(this.simEgo,steer,accel,vp);
    this.stepCount++;
    this.path.push({x:this.simEgo.x,y:this.simEgo.y,yaw:this.simEgo.yaw,v:this.simEgo.v,a:accel,st:steer,gear:this.simEgo.gear,t:this.stepCount*vp.dt});

    for(const ob of obstacles){if(egoCol(this.simEgo,vp,ob)){this.alive=false;this.score-=80;return;}}
    if(this.simEgo.x<GPU.xMin||this.simEgo.x>GPU.xMax||this.simEgo.y<GPU.yMin||this.simEgo.y>GPU.yMax){this.alive=false;this.score-=70;return;}

    const d=hypot(goal.x-this.simEgo.x,goal.y-this.simEgo.y);
    const yawErr=Math.abs(wrapPi(goal.yaw-this.simEgo.yaw));
    if(Number.isFinite(this.prevDist))this.score+=(this.prevDist-d)*8;
    this.prevDist=d;
    this.score+=Math.max(0,3.5-d)*0.4;
    this.score-=yawErr*0.15;

    if(d<0.45&&yawErr<deg2rad(12)){this.score+=140;this.alive=false;return;}
    if(this.stepCount>=maxSteps){this.alive=false;this.score-=d*2;}
  }
}

let evoState={running:false,gen:0,best:null,bestFit:-Infinity,log:[],bestBrain:null};

function buildGeneration(popSize,baseBrain,ego0){
  const agents=[];
  for(let i=0;i<popSize;i++){
    let brain;
    if(baseBrain){brain=baseBrain.clone();if(i!==0)brain.mutate(0.12);}else brain=new NeuralNetwork(16,12,3);
    agents.push(new AIAgent(ego0,brain));
  }
  return agents;
}

async function runEvolution(){
  if(evoState.running)return;
  evoState.running=true;evoState.log=[];evoState.gen=0;evoState.best=null;evoState.bestFit=-Infinity;
  const logEl=document.getElementById('evoLog');
  const barEl=document.getElementById('evoBar');
  logEl.textContent='';barEl.style.width='0%';

  const popSize=Math.max(8,+(document.getElementById('eP').value)||50);
  const maxGen=Math.max(1,+(document.getElementById('eG').value)||30);
  const vp={...cfg.vehicle};
  const goal=scene.slot.goal;
  const obstacles=scene.obstacles.map(ob=>({...ob,vx:0,vy:0}));
  const ego0={...scene.ego,v:0};

  for(let gen=0;gen<maxGen&&evoState.running;gen++){
    evoState.gen=gen+1;
    const agents=buildGeneration(popSize,evoState.bestBrain,ego0);
    const maxSteps=Math.max(220,Math.round((cfg.planner.maxTime||25)/vp.dt));
    for(let frame=0;frame<maxSteps;frame++){
      let anyAlive=false;
      for(const a of agents){if(a.alive){a.update(obstacles,goal,vp,maxSteps);anyAlive=true;}}
      if(!anyAlive)break;
    }

    agents.sort((a,b)=>b.score-a.score);
    const best=agents[0];
    const endPose=best.simEgo;
    const pv=validateParking(endPose,scene.slot,vp);
    if(best.score>evoState.bestFit){
      evoState.bestFit=best.score;
      evoState.bestBrain=best.brain.clone();
      evoState.best={score:best.score,brain:evoState.bestBrain,path:best.path,parkScore:pv.score,endPose:{...endPose},generation:gen+1};
    }

    barEl.style.width=((gen+1)/maxGen*100)+'%';
    const msg=`G${gen+1}: score=${best.score.toFixed(1)} åœè½¦è¯„åˆ†=${pv.score.toFixed(0)} è·ç¦»=${hypot(goal.x-endPose.x,goal.y-endPose.y).toFixed(2)}m`;
    evoState.log.push(msg);logEl.textContent=evoState.log.join('\n');logEl.scrollTop=logEl.scrollHeight;
    document.getElementById('mSt').textContent=`è®­ç»ƒ G${gen+1}`;
    await new Promise(r=>setTimeout(r,0));
  }

  if(evoState.best){
    evoState.log.push(`âœ… å®Œæˆ! æœ€ä¼˜åˆ†æ•°=${evoState.bestFit.toFixed(1)} (G${evoState.best.generation})`);
  }else{
    evoState.log.push('âš ï¸ è®­ç»ƒä¸­æ­¢ï¼Œæœªè·å¾—æœ‰æ•ˆç­–ç•¥');
  }
  logEl.textContent=evoState.log.join('\n');
  logEl.scrollTop=logEl.scrollHeight;
  evoState.running=false;
}

// â•â•â•â•â•â•â•â•â•â•â• CANVAS â•â•â•â•â•â•â•â•â•â•â•
const canvas=document.getElementById('canvas'),ctx=canvas.getContext('2d'),dpr=window.devicePixelRatio||1;
function resize(){const r=canvas.parentElement.getBoundingClientRect();canvas.width=r.width*dpr;canvas.height=r.height*dpr;}
window.addEventListener('resize',resize);resize();
const cam={scale:45,ox:0,oy:0};
cam.ox=canvas.width/(2*dpr)-2*cam.scale;cam.oy=canvas.height/(2*dpr)+2*cam.scale;
function w2s(wx,wy){return{x:cam.ox+wx*cam.scale,y:cam.oy-wy*cam.scale};}
function s2w(sx,sy){return{x:(sx-cam.ox)/cam.scale,y:(cam.oy-sy)/cam.scale};}

// â•â•â•â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â•â•â•â•
const cfg={
  sensor:{lidarRange:25,lidarFov:180,ussRange:5},
  vehicle:{length:4.6,width:1.9,wheelbase:2.75,frontOverhang:0.95,rearOverhang:0.90,
    maxSteer:deg2rad(35),maxV:3,maxA:1.5,inflation:0.20,dt:0.2},
  planner:{maxTime:25,resXY:0.5,resYaw:36,vPlan:1.5,wRev:2,wGear:8,wSteer:1,goalPosTol:0.6,goalYawTol:15},
  replanEvery:2};
function syncCfg(){
  cfg.sensor.lidarRange=+document.getElementById('iLR').value||25;
  cfg.sensor.lidarFov=+document.getElementById('iLF').value||180;
  cfg.sensor.ussRange=+document.getElementById('iUR').value||5;
  cfg.replanEvery=Math.max(1,+document.getElementById('iRP').value||3);
  cfg.vehicle.length=+document.getElementById('iVL').value||4.6;
  cfg.vehicle.width=+document.getElementById('iVW').value||1.9;
  cfg.vehicle.wheelbase=+document.getElementById('iWB').value||2.75;
  cfg.vehicle.frontOverhang=+document.getElementById('iFO').value||0.95;
  cfg.vehicle.rearOverhang=+document.getElementById('iRO').value||0.90;
  cfg.vehicle.maxSteer=deg2rad(+document.getElementById('iMS').value||35);
  cfg.vehicle.inflation=+document.getElementById('iIF').value||0.20;
  cfg.vehicle.dt=+document.getElementById('iDT').value||0.2;
  cfg.planner.maxTime=+document.getElementById('iPT').value||25;
  cfg.planner.vPlan=+document.getElementById('iPV').value||1.5;
  cfg.planner.resXY=+document.getElementById('iGR').value||0.5;
  syncOncomingVehicleSize();
}
document.querySelectorAll('#pn input').forEach(el=>el.addEventListener('input',syncCfg));

// â•â•â•â•â•â•â•â•â•â•â• SCENE â•â•â•â•â•â•â•â•â•â•â•
function getSlotSize(type,vp=cfg.vehicle){
  const longMargin=type==='parallel'?1.4:1.1;
  const latMargin=0.9;
  return{len:vp.length+longMargin,wid:vp.width+latMargin};
}

function makeSlot(goal,type='parallel'){
  const d=getSlotSize(type,cfg.vehicle),hl=d.len/2,hw=d.wid/2;
  const c=Math.cos(goal.yaw),sg=Math.sin(goal.yaw);
  const poly=[
    {x:goal.x+c*hl-sg*hw,y:goal.y+sg*hl+c*hw},
    {x:goal.x+c*hl+sg*hw,y:goal.y+sg*hl-c*hw},
    {x:goal.x-c*hl+sg*hw,y:goal.y-sg*hl-c*hw},
    {x:goal.x-c*hl-sg*hw,y:goal.y-sg*hl+c*hw},
  ];
  return{poly,goal:{...goal},type};
}


function makeTwoWaySingleLaneRoad(yCenter=3.6,laneWidth=3.4){
  return {yCenter,laneWidth,shoulder:0.25};
}

function laneOutAmountY(y,road){
  if(!road)return 0;
  const limit=road.laneWidth+road.shoulder;
  return Math.max(0,Math.abs(y-road.yCenter)-limit);
}

function laneOutAmountPose(pose,vp,road){
  if(!road)return 0;
  const corners=getEgoCorners(pose,vp);
  let out=0;
  for(const c of corners)out=Math.max(out,laneOutAmountY(c.y,road));
  return out;
}

function keepOncomingInOppositeLane(){
  if(!scene||!scene.road)return;
  const r=scene.road;
  const egoLane=Math.sign(scene.ego.y-r.yCenter)||1;
  const oncomingLaneY=r.yCenter-egoLane*r.laneWidth*0.5;
  for(const ob of scene.obstacles||[]){
    if(ob.kind==='å¯¹å‘è½¦')ob.y=oncomingLaneY;
  }
}

function mkScene(){return{t:0,stepN:0,
  road:makeTwoWaySingleLaneRoad(3.6,3.4),
  ego:{x:2,y:5.3,yaw:0,v:0,gear:1},
  slot:makeSlot({x:10.75,y:1.0,yaw:0},'parallel'),
  obstacles:[
    {id:uid(),shape:'rect',x:5,y:1.0,yaw:0,w:4.5,h:1.8,vx:0,vy:0,kind:'åœè½¦'},
    {id:uid(),shape:'rect',x:16.5,y:1.0,yaw:0,w:4.5,h:1.8,vx:0,vy:0,kind:'åœè½¦'},
    {id:uid(),shape:'circle',x:11,y:6.5,yaw:0,r:0.3,vx:-0.3,vy:-0.1,kind:'è¡Œäºº'},
    {id:uid(),shape:'rect',x:3,y:-1.5,yaw:0,w:0.6,h:0.6,vx:0,vy:0,kind:'é”¥æ¡¶'}]};}
let scene=mkScene(),running=false,trajectory=null,trajectoryIndex=1,perceivedObs=[],planningObstacles=[];
syncCfg();
applySceneMotionProfile();
keepOncomingInOppositeLane();
let totalDist=0,gearSwitches=0,lastPlanMs=0,planStatus='idle',stepsSincePlan=999,simStepCount=0;
let showCSpace=false,showUSS=true,lastParkVal=null;
let avoidState={active:false,goal:null,causeId:null,mode:'none',startT:0};
let avoidTriggerState={id:null,count:0};
let movingObsTracks=new Map();
let avoidRangeLatch=new Map();

// â•â•â•â•â•â•â•â•â•â•â• SIMULATION STEP â•â•â•â•â•â•â•â•â•â•â•
let planning=false,emergencyHold=false;
let alignState={lastGear:1,lastErr:Infinity,steps:0,startT:0,gearSw:0,steerFlip:0,lastSteerSign:0,abortN:0};
let policyBandit={policies:[],active:null,episode:null};


function resetAlignState(keepAbort=false){
  alignState={
    lastGear:1,lastErr:Infinity,steps:0,startT:0,
    gearSw:0,steerFlip:0,lastSteerSign:0,
    abortN:keepAbort?alignState.abortN:0
  };
}

function exceedAlignLimits(scene,vp){
  const maxSteps=75;
  const maxTime=11.5;
  const maxGearSwitch=4;
  const maxSteerFlip=9;
  const dt=Math.max(0,scene.t-alignState.startT);
  return alignState.steps>maxSteps||dt>maxTime||alignState.gearSw>maxGearSwitch||alignState.steerFlip>maxSteerFlip;
}

function initPolicyBandit(){
  if(policyBandit.policies.length)return;
  const base={vPlan:cfg.planner.vPlan,wRev:cfg.planner.wRev,wGear:cfg.planner.wGear,wSteer:cfg.planner.wSteer,goalPosTol:cfg.planner.goalPosTol,goalYawTol:cfg.planner.goalYawTol};
  const vars=[
    {name:'base',mul:{vPlan:1,wRev:1,wGear:1,wSteer:1,gPos:1,gYaw:1}},
    {name:'fast',mul:{vPlan:1.15,wRev:0.9,wGear:0.9,wSteer:1,gPos:0.95,gYaw:0.92}},
    {name:'smooth',mul:{vPlan:0.9,wRev:1.1,wGear:1.2,wSteer:0.9,gPos:1.05,gYaw:1.08}},
    {name:'tight',mul:{vPlan:0.95,wRev:1.0,wGear:1.05,wSteer:1.2,gPos:0.78,gYaw:0.75}},
  ];
  policyBandit.policies=vars.map((v,i)=>({
    id:i,name:v.name,
    planner:{
      vPlan:base.vPlan*v.mul.vPlan,wRev:base.wRev*v.mul.wRev,wGear:base.wGear*v.mul.wGear,wSteer:base.wSteer*v.mul.wSteer,
      goalPosTol:base.goalPosTol*v.mul.gPos,goalYawTol:base.goalYawTol*v.mul.gYaw,maxTime:cfg.planner.maxTime,resXY:cfg.planner.resXY,resYaw:cfg.planner.resYaw,
    },
    n:0,reward:0,best:Infinity
  }));

  try{
    const saved=JSON.parse(localStorage.getItem('apaPolicyBandit')||'null');
    if(saved&&Array.isArray(saved)&&saved.length===policyBandit.policies.length){
      for(let i=0;i<saved.length;i++){
        policyBandit.policies[i].n=saved[i].n||0;
        policyBandit.policies[i].reward=saved[i].reward||0;
        policyBandit.policies[i].best=saved[i].best||Infinity;
      }
    }
  }catch(_){ }
}

function selectPolicyForEpisode(){
  initPolicyBandit();
  const total=Math.max(1,policyBandit.policies.reduce((s,p)=>s+p.n,0));
  let pick=policyBandit.policies[0],best=-1e9;
  for(const p of policyBandit.policies){
    const mean=p.n?p.reward/p.n:0;
    const bonus=p.n?Math.sqrt(2*Math.log(total+1)/p.n):2.2;
    const ucb=mean+bonus;
    if(ucb>best){best=ucb;pick=p;}
  }
  policyBandit.active=pick;
  Object.assign(cfg.planner,pick.planner);
  policyBandit.episode={t0:scene.t,d0:totalDist,g0:gearSwitches,updated:false};
}

function updatePolicyReward(success){
  const ep=policyBandit.episode,p=policyBandit.active;
  if(!ep||!p||ep.updated)return;
  const dt=Math.max(0.1,scene.t-ep.t0),dd=Math.max(0,totalDist-ep.d0),dg=Math.max(0,gearSwitches-ep.g0);
  const pv=lastParkVal||validateParking(scene.ego,scene.slot,cfg.vehicle);
  const fitness=dt+0.8*dd+1.5*dg+0.12*(100-(pv.score||0))+(success?0:25);
  const reward=1/(1+fitness);
  p.n++;p.reward+=reward;p.best=Math.min(p.best,fitness);
  ep.updated=true;
  try{localStorage.setItem('apaPolicyBandit',JSON.stringify(policyBandit.policies.map(x=>({n:x.n,reward:x.reward,best:x.best}))));}catch(_){ }
}

function resetAvoidState(){
  avoidState={active:false,goal:null,causeId:null,mode:'none',startT:0};
  avoidTriggerState={id:null,count:0};
}

function buildReverseYieldGoal(ego,vp,obs){
  const bx=-Math.cos(ego.yaw),by=-Math.sin(ego.yaw);
  const side={x:-by,y:bx};
  const distSet=[1.4,2.0,2.8,3.4];
  const sideSet=[0,0.4,-0.4];
  for(const d of distSet){
    for(const sd of sideSet){
      const gx=ego.x+bx*d+side.x*sd,gy=ego.y+by*d+side.y*sd;
      if(gx<GPU.xMin+0.8||gx>GPU.xMax-0.8||gy<GPU.yMin+0.8||gy>GPU.yMax-0.8)continue;
      const cand={x:gx,y:gy,yaw:ego.yaw,v:0,gear:-1};
      if(laneOutAmountPose(cand,vp,scene.road)>0.25)continue;
      if(isPoseSafeForAvoidGoal(cand,obs||[],vp,null))return {x:gx,y:gy,yaw:ego.yaw};
    }
  }
  return null;
}

function advanceSceneOnly(dt){
  for(const ob of scene.obstacles){if(ob.vx||ob.vy){ob.x+=(ob.vx||0)*dt;ob.y+=(ob.vy||0)*dt;}}
  scene.t+=dt;scene.stepN++;simStepCount++;
  lastParkVal=validateParking(scene.ego,scene.slot,cfg.vehicle);
}

async function stepOnce(){
  if(planning)return;
  const vp=cfg.vehicle,dt=vp.dt;

  // Check if parked - use strict validation
  const parkVal=validateParking(scene.ego,scene.slot,vp);
  if(isStrictAligned(scene.ego,scene.slot,vp)){
    planStatus='success';running=false;lastParkVal=parkVal;
    updatePolicyReward(true);
    document.getElementById('btnPlay').textContent='â–¶ å¼€å§‹';
    document.getElementById('btnPlay').classList.remove('running');
    showParkScore(parkVal);updateMetrics();return;
  }

  perceivedObs=getPerceivedObs();
  const trackedMovingObs=updateTrackedMovingObstacles(perceivedObs);
  planningObstacles=getPlanningObstacles();

  const movingHit=detectMovingObstacleWithin(scene.ego,trackedMovingObs,vp,2.0);
  const blockedByMoving=trajectory&&trajectory.length>1&&trajectoryIndex<trajectory.length
    ?isPathBlockedSoon(trajectory,trajectoryIndex,trackedMovingObs,vp)
    :false;
  const motionNeedsAvoid=movingHit?shouldTriggerAvoidByMotion(scene.ego,movingHit,trajectory,trajectoryIndex,vp):false;

  if(avoidState.mode==='none'&&!avoidState.active&&movingHit&&motionNeedsAvoid){
    avoidTriggerState.count=(avoidTriggerState.id===movingHit.id)?(avoidTriggerState.count+1):1;
    avoidTriggerState.id=movingHit.id||null;
    if(avoidTriggerState.count>=2){
      avoidState={active:false,goal:null,causeId:movingHit.id||null,mode:'wait',startT:scene.t};
      trajectory=null;trajectoryIndex=1;stepsSincePlan=cfg.replanEvery;
      planStatus='avoiding';
    }
  }else if(!movingHit&&avoidState.mode==='none'){
    avoidTriggerState={id:null,count:0};
  }

  if(avoidState.mode==='wait'){
    scene.ego.v=0;
    const waitT=scene.t-avoidState.startT;
    if(!movingHit||!motionNeedsAvoid){
      resetAvoidState();
      trajectory=null;trajectoryIndex=1;stepsSincePlan=cfg.replanEvery;planStatus='planning';
    }else if((blockedByMoving&&waitT>=1.2)||waitT>=3.5){
      const avoidGoal=buildAvoidGoal(scene.ego,movingHit,scene.slot.goal,planningObstacles,vp);
      if(avoidGoal){
        avoidState={active:true,goal:avoidGoal,causeId:movingHit.id||null,mode:'avoid',startT:scene.t};
        trajectory=null;trajectoryIndex=1;stepsSincePlan=cfg.replanEvery;planStatus='avoiding';
      }else{
        const revGoal=buildReverseYieldGoal(scene.ego,vp,planningObstacles);
        if(revGoal){
          avoidState={active:true,goal:revGoal,causeId:movingHit.id||null,mode:'reverse',startT:scene.t};
          trajectory=null;trajectoryIndex=1;stepsSincePlan=cfg.replanEvery;planStatus='avoiding';
        }
      }
    }
    if(avoidState.mode==='wait'&&waitT>=6.0&&!avoidState.active){
      planStatus='nopath';running=false;
      document.getElementById('btnPlay').textContent='â–¶ å¼€å§‹';
      document.getElementById('btnPlay').classList.remove('running');
    }
    advanceSceneOnly(dt);
    updateMetrics();
    return;
  }

  if(avoidState.active&&isAvoidGoalReached(scene.ego,avoidState.goal)){
    resetAvoidState();
    trajectory=null;
    trajectoryIndex=1;
    stepsSincePlan=cfg.replanEvery;
    planStatus='planning';
  }
  if(avoidState.active&&scene.t-avoidState.startT>8.0){
    resetAvoidState();
    planStatus='nopath';running=false;
    document.getElementById('btnPlay').textContent='â–¶ å¼€å§‹';
    document.getElementById('btnPlay').classList.remove('running');
  }

  if(hasImmediateCollision(scene.ego,vp,planningObstacles)){
    engageEmergencyStop();
    updateMetrics();
    return;
  }

  if(emergencyHold){
    emergencyHold=false;
    planStatus='planning';
    stepsSincePlan=cfg.replanEvery;
  }

  if(!avoidState.active&&avoidState.mode==='none'&&shouldRunFinalAlign(scene.ego,scene.slot,vp)){
    if(planStatus!=='aligning'||alignState.steps===0)alignState.startT=scene.t;
    planStatus='aligning';
    const ok=runFinalAlignStep(scene.ego,scene.slot,vp,planningObstacles);
    scene.t+=dt;scene.stepN++;simStepCount++;
    lastParkVal=validateParking(scene.ego,scene.slot,vp);

    if(ok&&(isStrictAligned(scene.ego,scene.slot,vp)||isCenteredEnoughToStop(scene.ego,scene.slot,vp))){
      planStatus='success';running=false;
      updatePolicyReward(true);
      document.getElementById('btnPlay').textContent='â–¶ å¼€å§‹';
      document.getElementById('btnPlay').classList.remove('running');
      showParkScore(lastParkVal);
      resetAlignState();
    }else if(exceedAlignLimits(scene,vp)){
      // hard guard: prohibit endless angle rocking / shunting in final alignment
      alignState.abortN++;
      resetAlignState(true);
      trajectory=null;stepsSincePlan=cfg.replanEvery;planStatus='planning';
      if(alignState.abortN>=2){
        // two failed fine-align attempts: stop this episode and wait for restart/replan
        running=false;planStatus='nopath';
        document.getElementById('btnPlay').textContent='â–¶ å¼€å§‹';
        document.getElementById('btnPlay').classList.remove('running');
      }
    }
    updateMetrics();
    return;
  }

  stepsSincePlan++;
  const pathBlockedSoon=trajectory&&trajectory.length>1&&trajectoryIndex<trajectory.length
    ?isPathBlockedSoon(trajectory,trajectoryIndex,planningObstacles,vp)
    :false;
  const staticPathBlockedSoon=trajectory&&trajectory.length>1&&trajectoryIndex<trajectory.length
    ?isPathBlockedSoon(trajectory,trajectoryIndex,planningObstacles.filter(isStaticObstacle),vp)
    :false;
  const nearPathEnd=trajectory&&trajectory.length>3&&trajectoryIndex>=trajectory.length-3;
  const trackErr=trajectory&&trajectory.length>1&&trajectoryIndex<trajectory.length
    ?hypot(scene.ego.x-trajectory[trajectoryIndex].x,scene.ego.y-trajectory[trajectoryIndex].y)
    :0;
  const periodicReplanInt=avoidState.active?Math.max(2,cfg.replanEvery+1):Math.max(5,cfg.replanEvery+4);
  const shouldPeriodicReplan=!!trajectory&&stepsSincePlan>=periodicReplanInt&&(nearPathEnd||trackErr>0.95);
  if(!trajectory||pathBlockedSoon||staticPathBlockedSoon||shouldPeriodicReplan){
    planning=true;
    await computeGrid(planningObstacles,vp);
    document.getElementById('mGd').textContent=(GPU.ready?'GPU ':'CPU ')+GPU.ms.toFixed(1)+'ms';
    const t1=performance.now();
    const result=avoidState.active
      ?(avoidState.mode==='reverse'
        ?planHybridAStar(scene.ego,avoidState.goal,vp,{...cfg.planner,maxTime:Math.min(6,cfg.planner.maxTime),wRev:Math.min(0.8,cfg.planner.wRev*0.4),wGear:Math.max(9,cfg.planner.wGear*1.1),goalPosTol:Math.min(0.45,cfg.planner.goalPosTol),goalYawTol:Math.min(16,cfg.planner.goalYawTol),laneHardTol:0.08,wLane:Math.max(20,(cfg.planner.wLane||7)*2.5)})
        :planHybridAStar(scene.ego,avoidState.goal,vp,{...cfg.planner,maxTime:Math.min(8,cfg.planner.maxTime),wRev:Math.max(18,cfg.planner.wRev*3.5),wGear:Math.max(12,cfg.planner.wGear*1.5),goalPosTol:Math.min(0.5,cfg.planner.goalPosTol),goalYawTol:Math.min(20,cfg.planner.goalYawTol),laneHardTol:0.08,wLane:Math.max(20,(cfg.planner.wLane||7)*2.5)}))
      :planShortestParkingPath(scene.ego,vp,cfg.planner,planningObstacles);
    lastPlanMs=performance.now()-t1;
    trajectory=result?result.path:null;
    trajectoryIndex=1;
    stepsSincePlan=0;planning=false;
    planStatus=trajectory?(avoidState.active?'avoiding':'planning'):'nopath';
    if(!trajectory&&policyBandit.episode&&!policyBandit.episode.updated&&scene.t-policyBandit.episode.t0>cfg.planner.maxTime*0.6){updatePolicyReward(false);} 
  }
  if(trajectory&&trajectory.length>=2){
    trajectoryIndex=pickTrackingIndex(trajectory,trajectoryIndex,scene.ego,vp);
    const nxt=trajectory[Math.min(trajectoryIndex,trajectory.length-1)],pG=scene.ego.gear,pX=scene.ego.x,pY=scene.ego.y;

    if(willCollideOnNextStep(scene.ego,nxt,vp,planningObstacles)){
      engageEmergencyStop();
      updateMetrics();
      return;
    }

    scene.ego.gear=nxt.gear;
    const st=bicStep(scene.ego,nxt.st,nxt.a,vp);
    scene.ego.x=st.x;scene.ego.y=st.y;scene.ego.yaw=st.yaw;scene.ego.v=st.v;
    totalDist+=hypot(st.x-pX,st.y-pY);
    if(pG!==nxt.gear)gearSwitches++;
  }
  for(const ob of scene.obstacles){if(ob.vx||ob.vy){ob.x+=(ob.vx||0)*dt;ob.y+=(ob.vy||0)*dt;}}
  scene.t+=dt;scene.stepN++;simStepCount++;
  // Live parking validation
  lastParkVal=validateParking(scene.ego,scene.slot,vp);
  if(policyBandit.episode&&!policyBandit.episode.updated&&scene.t-policyBandit.episode.t0>cfg.planner.maxTime*1.4){
    planStatus='nopath';running=false;updatePolicyReward(false);
    document.getElementById('btnPlay').textContent='â–¶ å¼€å§‹';
    document.getElementById('btnPlay').classList.remove('running');
  }
  updateMetrics();
}

function pickTrackingIndex(path,startIdx,ego,vp){
  if(!path||path.length<2)return 1;
  let idx=clamp(startIdx||1,1,path.length-1);
  const catchDist=Math.max(0.45,vp.maxV*vp.dt*1.15);
  while(idx<path.length-1&&hypot(path[idx].x-ego.x,path[idx].y-ego.y)<catchDist)idx++;
  return idx;
}

function isPathBlockedSoon(path,startIdx,obs,vp){
  if(!path||!obs||!obs.length)return false;
  const from=clamp(startIdx||1,1,path.length-1);
  const to=Math.min(path.length-1,from+12);
  const sampleSweep=(p0,p1,ob,tPred)=>{
    const d=hypot(p1.x-p0.x,p1.y-p0.y);
    const yawDelta=Math.abs(wrapPi(p1.yaw-p0.yaw));
    const n=Math.max(1,Math.ceil(Math.max(d/0.22,yawDelta/deg2rad(6))));
    for(let k=0;k<=n;k++){
      const t=k/n;
      const pose={
        x:p0.x+(p1.x-p0.x)*t,
        y:p0.y+(p1.y-p0.y)*t,
        yaw:wrapPi(p0.yaw+wrapPi(p1.yaw-p0.yaw)*t),
      };
      const pob={...ob,x:ob.x+(ob.vx||0)*tPred,y:ob.y+(ob.vy||0)*tPred};
      if(egoCol(pose,vp,pob))return true;
    }
    return false;
  };
  for(let i=from;i<=to;i++){
    const tPred=(i-from+1)*vp.dt;
    const p0=path[Math.max(from-1,i-1)],p1=path[i];
    for(const ob of obs){
      if(sampleSweep(p0,p1,ob,tPred))return true;
    }
  }
  return false;
}

function hasImmediateCollision(ego,vp,obs){
  for(const ob of obs){if(egoCol(ego,vp,ob))return true;}
  return false;
}

function willCollideOnNextStep(ego,nxt,vp,obs){
  const probe={x:ego.x,y:ego.y,yaw:ego.yaw,v:ego.v,gear:nxt.gear};
  const st=bicStep(probe,nxt.st,nxt.a,vp);
  const tPred=vp.dt;
  const d=hypot(st.x-ego.x,st.y-ego.y);
  const yawDelta=Math.abs(wrapPi(st.yaw-ego.yaw));
  const n=Math.max(1,Math.ceil(Math.max(d/0.18,yawDelta/deg2rad(5))));
  for(const ob of obs){
    const pob={...ob,x:ob.x+(ob.vx||0)*tPred,y:ob.y+(ob.vy||0)*tPred};
    for(let k=0;k<=n;k++){
      const t=k/n;
      const pose={x:ego.x+(st.x-ego.x)*t,y:ego.y+(st.y-ego.y)*t,yaw:wrapPi(ego.yaw+wrapPi(st.yaw-ego.yaw)*t)};
      if(egoCol(pose,vp,pob))return true;
    }
  }
  return false;
}

function engageEmergencyStop(){
  emergencyHold=true;
  trajectory=null;
  trajectoryIndex=1;
  stepsSincePlan=cfg.replanEvery;
  scene.ego.v=0;
  planStatus='emergency';
}



function isMovingObstacle(ob){
  return (Math.abs(ob.vx||0)>1e-3||Math.abs(ob.vy||0)>1e-3)&&ob.kind!=='åœè½¦';
}

function isStaticObstacle(ob){
  return !isMovingObstacle(ob);
}

function updateTrackedMovingObstacles(perceived){
  const alpha=0.35;
  const seen=new Set();
  for(const ob of perceived){
    if(!isMovingObstacle(ob))continue;
    const id=ob.id||uid();
    seen.add(id);
    const prev=movingObsTracks.get(id);
    const sx=prev?prev.x*(1-alpha)+ob.x*alpha:ob.x;
    const sy=prev?prev.y*(1-alpha)+ob.y*alpha:ob.y;
    const stepDx=prev?(sx-prev.x):0;
    const stepDy=prev?(sy-prev.y):0;
    const stepDist=hypot(stepDx,stepDy);
    const cur={
      ...ob,
      id,
      x:sx,
      y:sy,
      vx:prev?(prev.vx||0)*(1-alpha)+(ob.vx||0)*alpha:(ob.vx||0),
      vy:prev?(prev.vy||0)*(1-alpha)+(ob.vy||0)*alpha:(ob.vy||0),
      stepDx,stepDy,stepDist,
      miss:0,
    };
    movingObsTracks.set(id,cur);
  }
  for(const [id,tr] of movingObsTracks){
    if(seen.has(id))continue;
    tr.miss=(tr.miss||0)+1;
    if(tr.miss>6){
      movingObsTracks.delete(id);
      avoidRangeLatch.delete(id);
    }
  }
  return Array.from(movingObsTracks.values());
}

function getRectCorners(x,y,yaw,w,h){
  const c=Math.cos(yaw),s=Math.sin(yaw),hw=w/2,hh=h/2;
  return[
    {x:x+c*hw-s*hh,y:y+s*hw+c*hh},
    {x:x+c*hw+s*hh,y:y+s*hw-c*hh},
    {x:x-c*hw+s*hh,y:y-s*hw-c*hh},
    {x:x-c*hw-s*hh,y:y-s*hw+c*hh},
  ];
}

function rectRectClearance(a,b){
  if(cpuSAT(a.x,a.y,a.yaw,a.w,a.h,b.x,b.y,b.yaw,b.w,b.h))return 0;
  const ac=getRectCorners(a.x,a.y,a.yaw,a.w,a.h);
  const bc=getRectCorners(b.x,b.y,b.yaw,b.w,b.h);
  let minD=Infinity;
  for(const p of ac){
    for(let i=0;i<4;i++)minD=Math.min(minD,pointToSegDist(p,bc[i],bc[(i+1)%4]));
  }
  for(const p of bc){
    for(let i=0;i<4;i++)minD=Math.min(minD,pointToSegDist(p,ac[i],ac[(i+1)%4]));
  }
  return minD;
}

function movingObstacleClearanceToEgo(ego,ob,vp){
  const egoRect={x:ego.x,y:ego.y,yaw:ego.yaw,w:vp.length+2*vp.inflation,h:vp.width+2*vp.inflation};
  if(ob.shape==='circle'){
    const hit=cpuRC(ego.x,ego.y,ego.yaw,egoRect.w,egoRect.h,ob.x,ob.y,ob.r||0.3);
    if(hit)return 0;
    const cs=getRectCorners(egoRect.x,egoRect.y,egoRect.yaw,egoRect.w,egoRect.h);
    let edgeD=Infinity;
    for(let i=0;i<4;i++)edgeD=Math.min(edgeD,pointToSegDist({x:ob.x,y:ob.y},cs[i],cs[(i+1)%4]));
    return Math.max(0,edgeD-(ob.r||0.3));
  }
  return rectRectClearance(egoRect,{x:ob.x,y:ob.y,yaw:ob.yaw||0,w:ob.w||1,h:ob.h||1});
}


function shouldTriggerAvoidByMotion(ego,ob,trajectory,trajectoryIndex,vp){
  if(!ob)return false;
  const dx=ego.x-ob.x,dy=ego.y-ob.y,dn=Math.max(1e-4,hypot(dx,dy));
  const ux=dx/dn,uy=dy/dn;
  const toward=(ob.stepDx||0)*ux+(ob.stepDy||0)*uy; // >0 toward ego
  const movingAway=toward<-0.025;
  const meaningfulStep=(ob.stepDist||0)>=0.02;
  const pathThreat=trajectory&&trajectory.length>1&&trajectoryIndex<trajectory.length
    ?isPathBlockedSoon(trajectory,trajectoryIndex,[ob],vp)
    :false;
  if(movingAway&&!pathThreat)return false;
  return pathThreat||(meaningfulStep&&toward>0.01);
}

function detectMovingObstacleWithin(ego,obs,vp,r=2){
  let best=null,bestGap=Infinity;
  const seen=new Set();
  for(const ob of obs){
    if(!isMovingObstacle(ob))continue;
    const id=ob.id||uid();
    seen.add(id);
    const gap=movingObstacleClearanceToEgo(ego,ob,vp);
    const prevIn=avoidRangeLatch.get(id)||false;
    const inRange=prevIn?gap<=r+0.35:gap<=r;
    avoidRangeLatch.set(id,inRange);
    if(inRange&&gap<bestGap){best=ob;bestGap=gap;}
  }
  for(const id of Array.from(avoidRangeLatch.keys()))if(!seen.has(id))avoidRangeLatch.delete(id);
  return best;
}

function isPoseSafeForAvoidGoal(pose,obs,vp,sourceId){
  for(const ob of obs){
    if(sourceId&&ob.id===sourceId)continue;
    if(egoCol(pose,vp,ob))return false;
  }
  return true;
}

function buildAvoidGoal(ego,ob,slotGoal,obs,vp){
  const dX=ego.x-(ob.x||0),dY=ego.y-(ob.y||0);
  const dN=Math.max(1e-4,hypot(dX,dY));
  const away={x:dX/dN,y:dY/dN};
  const fwd={x:Math.cos(ego.yaw),y:Math.sin(ego.yaw)};
  const side={x:-fwd.y,y:fwd.x};
  const sideSign=Math.sign(side.x*away.x+side.y*away.y)||1;
  const yawBias=clamp(wrapPi(slotGoal.yaw-ego.yaw),-deg2rad(20),deg2rad(20));
  const yawSet=[wrapPi(ego.yaw+yawBias),ego.yaw,wrapPi(ego.yaw+yawBias*0.5)];
  const fwdSet=[2.4,3.0,3.6,1.8];
  const sideSet=[0.9,1.3,1.8];
  const awaySet=[0.8,1.2,1.6];

  for(const gyaw of yawSet){
    for(const fd of fwdSet){
      for(const sd of sideSet){
        for(const ad of awaySet){
          const gx=ego.x+fwd.x*fd+side.x*sideSign*sd+away.x*ad;
          const gy=ego.y+fwd.y*fd+side.y*sideSign*sd+away.y*ad;
          if(gx<GPU.xMin+0.8||gx>GPU.xMax-0.8||gy<GPU.yMin+0.8||gy>GPU.yMax-0.8)continue;
          const cand={x:gx,y:gy,yaw:gyaw,v:0,gear:1};
          if(laneOutAmountPose(cand,vp,scene.road)>0.08)continue;
          if(isPoseSafeForAvoidGoal(cand,obs||[],vp,ob.id))return {x:gx,y:gy,yaw:gyaw};
        }
      }
    }
  }
  return null;
}

function isAvoidGoalReached(ego,goal){
  if(!goal)return false;
  return hypot(ego.x-goal.x,ego.y-goal.y)<=0.55&&Math.abs(rad2deg(wrapPi(ego.yaw-goal.yaw)))<=12;
}

function pathLength(path){
  if(!path||path.length<2)return Infinity;
  let d=0;
  for(let i=1;i<path.length;i++)d+=hypot(path[i].x-path[i-1].x,path[i].y-path[i-1].y);
  return d;
}

function getAngledParkingPreference(slot,ego){
  if(!slot||slot.type!=='angled')return {goals:[slot.goal,{...slot.goal,yaw:wrapPi(slot.goal.yaw+PI)}],finalGear:null,mode:'normal'};
  const rel=wrapPi(slot.goal.yaw-(scene.road?.yaw||0));
  // é¡ºé±¼éª¨ï¼šå€’è½¦å…¥åº“ï¼›é€†é±¼éª¨ï¼šè½¦å¤´æ³Šå…¥
  const isForwardFishbone=rel>=0;
  if(isForwardFishbone){
    return {
      goals:[{...slot.goal,yaw:wrapPi(slot.goal.yaw+PI)}],
      finalGear:-1,
      mode:'reverse-in',
    };
  }
  return {
    goals:[slot.goal],
    finalGear:1,
    mode:'head-in',
  };
}

function planShortestParkingPath(ego,vp,planner,obs){
  const pref=getAngledParkingPreference(scene.slot,ego);
  const goals=pref.goals;
  let bestRes=null,bestScore=Infinity;
  for(const g of goals){
    const localPc={...planner,goalPosTol:Math.min(0.45,planner.goalPosTol||0.6),goalYawTol:Math.min(8,planner.goalYawTol||15),wCorner:Math.max(0.8,planner.wCorner||0.8)};
    const res=planHybridAStar(ego,g,vp,localPc);
    if(!res)continue;
    if(pref.finalGear!==null&&res.path&&res.path.length>2){
      const tail=res.path.slice(-Math.min(6,res.path.length));
      const tailGear=tail.reduce((acc,p)=>acc+(p.gear||1),0)>=0?1:-1;
      if(tailGear!==pref.finalGear)continue;
    }
    const len=pathLength(res.path);
    const eva=evaluatePlannedPath(res.path,{...scene.slot,goal:g},vp,obs);
    if(!eva.ok)continue;
    const score=len+2.2*eva.score;
    if(score<bestScore){bestScore=score;bestRes=res;}
  }
  return bestRes;
}

function applyMotionProfile(ob){
  if(!ob||!ob.kind)return;
  if(ob.kind==='æ¨è½¦')ob.kind='å¯¹å‘è½¦';
  const target=MOVING_KIND_SPEED[ob.kind];
  if(!target)return;
  const vx=ob.vx||0,vy=ob.vy||0,base=Math.max(1e-4,hypot(vx,vy));
  ob.vx=vx===0&&vy===0?-target:target*vx/base;
  ob.vy=vx===0&&vy===0?0:target*vy/base;
  if(ob.kind==='å¯¹å‘è½¦'&&ob.shape==='rect'){
    ob.w=cfg.vehicle.length;
    ob.h=cfg.vehicle.width;
  }
}

function applySceneMotionProfile(){
  for(const ob of scene.obstacles)applyMotionProfile(ob);
  keepOncomingInOppositeLane();
}

function syncOncomingVehicleSize(){
  if(!scene||!scene.obstacles)return;
  for(const ob of scene.obstacles){
    if(ob.kind==='å¯¹å‘è½¦'&&ob.shape==='rect'){
      ob.w=cfg.vehicle.length;
      ob.h=cfg.vehicle.width;
    }
  }
}

function poseErrorInGoalFrame(ego,goal){
  const c=Math.cos(goal.yaw),sg=Math.sin(goal.yaw);
  const dx=ego.x-goal.x,dy=ego.y-goal.y;
  return{longErr:c*dx+sg*dy,latErr:-sg*dx+c*dy,yawErr:wrapPi(ego.yaw-goal.yaw)};
}

function shouldRunFinalAlign(ego,slot,vp){
  const e=poseErrorInGoalFrame(ego,getEvalGoalForPose(slot,ego));
  const nearGoal=Math.hypot(ego.x-slot.goal.x,ego.y-slot.goal.y)<1.5;
  const centerInside=pointInPoly({x:ego.x,y:ego.y},slot.poly);
  const roughAligned=Math.abs(e.latErr)<0.7&&Math.abs(rad2deg(e.yawErr))<28;
  return nearGoal&&centerInside&&roughAligned;
}

function isStrictAligned(ego,slot,vp){
  const e=poseErrorInGoalFrame(ego,getEvalGoalForPose(slot,ego));
  const pv=validateParking(ego,slot,vp);
  return pv.pass&&Math.abs(rad2deg(e.yawErr))<=0.8&&Math.abs(e.latErr)<=0.05&&Math.abs(e.longErr)<=0.08&&pv.minLineGap>=0.04;
}

function isCenteredEnoughToStop(ego,slot,vp){
  const e=poseErrorInGoalFrame(ego,getEvalGoalForPose(slot,ego));
  const pv=validateParking(ego,slot,vp);
  return pv.pass&&Math.abs(rad2deg(e.yawErr))<=1.0&&Math.abs(e.latErr)<=0.06&&Math.abs(e.longErr)<=0.10&&Math.abs(ego.v)<=0.08;
}

function runFinalAlignStep(ego,slot,vp,obs){
  alignState.steps++;
  const e0=poseErrorInGoalFrame(ego,getEvalGoalForPose(slot,ego));
  const yawAbs=Math.abs(e0.yawErr),longAbs=Math.abs(e0.longErr);

  let desiredSteer=clamp(-(3.4*e0.yawErr+2.1*e0.latErr),-vp.maxSteer*0.95,vp.maxSteer*0.95);
  if(yawAbs>deg2rad(4.5)){
    const minTurn=vp.maxSteer*0.32;
    if(Math.abs(desiredSteer)<minTurn)desiredSteer=Math.sign(desiredSteer||e0.yawErr||1)*minTurn;
  }

  const longDeadband=0.09;
  const gearPref=longAbs>longDeadband?(e0.longErr>0?-1:1):alignState.lastGear;
  const allowOppositeGear=longAbs>0.18||Math.abs(rad2deg(e0.yawErr))>6.5||alignState.steps%4===0;
  const gearSet=allowOppositeGear?[gearPref,-gearPref]:[gearPref];
  const speedSet=[0.18,0.28,0.36];
  const steerSet=[
    clamp(desiredSteer*1.2,-vp.maxSteer,vp.maxSteer),
    desiredSteer,
    clamp(desiredSteer*0.8,-vp.maxSteer,vp.maxSteer),
    clamp(desiredSteer+vp.maxSteer*0.18,-vp.maxSteer,vp.maxSteer),
    clamp(desiredSteer-vp.maxSteer*0.18,-vp.maxSteer,vp.maxSteer),
    0,
  ];

  let best=null;
  for(const gear of gearSet){
    for(const sp of speedSet){
      for(const steer of steerSet){
        let st={x:ego.x,y:ego.y,yaw:ego.yaw,v:ego.v,gear};
        const a=clamp((gear*sp-ego.v)/vp.dt,-vp.maxA,vp.maxA);
        let hit=false;
        for(let k=0;k<3;k++){
          st=bicStep(st,steer,a,vp);
          const tPred=(k+1)*vp.dt;
          for(const ob of obs){
            const pob={...ob,x:ob.x+(ob.vx||0)*tPred,y:ob.y+(ob.vy||0)*tPred};
            if(egoCol(st,vp,pob)){hit=true;break;}
          }
          if(hit)break;
        }
        if(hit)continue;

        const ne=poseErrorInGoalFrame(st,getEvalGoalForPose(slot,st));
        const corners=getEgoCorners(st,vp);
        let minGap=Infinity;
        for(const c of corners)minGap=Math.min(minGap,pointToPolyDist(c,slot.poly));
        const outPenalty=minGap< -0.14 ? Math.abs(minGap)*18 : 0;
        const switchPenalty=gear!==alignState.lastGear?0.52:0;
        const antiShuntPenalty=(gear!==gearPref&&longAbs<0.28)?0.75:0;
        const sign=Math.abs(steer)>vp.maxSteer*0.08?Math.sign(steer):0;
        const flipPenalty=(sign!==0&&alignState.lastSteerSign!==0&&sign!==alignState.lastSteerSign)?0.42:0;
        const steerPenalty=0.10*Math.abs(steer-desiredSteer)+0.03*Math.abs(steer);
        const progress=(Math.abs(e0.yawErr)+1.25*Math.abs(e0.latErr)+1.35*Math.abs(e0.longErr))-(Math.abs(ne.yawErr)+1.25*Math.abs(ne.latErr)+1.35*Math.abs(ne.longErr));
        const lanePenalty=laneOutAmountPose(st,vp,scene.road)*4.0;
        const cost=4.3*Math.abs(ne.yawErr)+3.4*Math.abs(ne.latErr)+2.5*Math.abs(ne.longErr)+switchPenalty+antiShuntPenalty+flipPenalty+steerPenalty+outPenalty+lanePenalty-1.2*progress;
        if(!best||cost<best.cost)best={st,gear,steer,cost};
      }
    }
  }

  if(!best){
    alignState.lastGear*=-1;
    ego.v=0;
    return false;
  }

  const px=ego.x,py=ego.y;
  ego.gear=best.gear;ego.x=best.st.x;ego.y=best.st.y;ego.yaw=best.st.yaw;ego.v=best.st.v;
  totalDist+=hypot(best.st.x-px,best.st.y-py);

  if(best.gear!==alignState.lastGear)alignState.gearSw++;
  const steerSign=Math.abs(best.steer)>vp.maxSteer*0.08?Math.sign(best.steer):0;
  if(steerSign!==0&&alignState.lastSteerSign!==0&&steerSign!==alignState.lastSteerSign)alignState.steerFlip++;
  if(steerSign!==0)alignState.lastSteerSign=steerSign;

  const ne=poseErrorInGoalFrame(ego,getEvalGoalForPose(slot,ego));
  const newErr=Math.abs(ne.yawErr)+1.25*Math.abs(ne.latErr)+1.35*Math.abs(ne.longErr);
  alignState.lastErr=newErr;
  alignState.lastGear=best.gear;
  return true;
}

function showParkScore(pv){
  const el=document.getElementById('PS');
  el.style.display='block';
  el.innerHTML=`<div style="color:${pv.pass?'var(--ok)':'var(--er)'}">
    ${pv.pass?'âœ… æ³Šè½¦åˆæ ¼':'âŒ æ³Šè½¦ä¸åˆæ ¼'}</div>
    <div>èˆªå‘åå·®: ${pv.yawErr.toFixed(1)}Â° ${pv.yawPass?'âœ“':'âœ—'}</div>
    <div>æ¨ªå‘åå·®: ${(pv.latErr*100).toFixed(0)}cm ${pv.latPass?'âœ“':'âœ—'}</div>
    <div>çº¿è·ä½™é‡: ${(pv.minLineGap*100).toFixed(0)}cm ${pv.linePass?'âœ“':'âœ—'}</div>
    <div style="color:var(--ev)">ç»¼åˆè¯„åˆ†: ${pv.score.toFixed(0)}/100</div>`;
}

function updateMetrics(){
  document.getElementById('mT').textContent=scene.t.toFixed(1)+'s';
  document.getElementById('mG').textContent=gearSwitches;
  document.getElementById('mD').textContent=totalDist.toFixed(1)+'m';
  document.getElementById('mPl').textContent=lastPlanMs.toFixed(0)+'ms';
  document.getElementById('hudT').textContent=scene.t.toFixed(2);
  document.getElementById('hudS').textContent=scene.stepN;
  const sb=document.getElementById('SB');sb.className=planStatus;
  const labels={idle:'ç©ºé—²',planning:'è§„åˆ’ä¸­',avoiding:'ä¸»åŠ¨é¿éšœ',aligning:'å§¿æ€è°ƒæ•´',success:'â—ˆ æ³Šå…¥',nopath:'æ— è·¯å¾„',emergency:'ç´§æ€¥åˆ¶åŠ¨'};
  sb.textContent=labels[planStatus]||'â€”';
  const ms=document.getElementById('mSt');ms.textContent=labels[planStatus]||'â€”';
  ms.className='MV '+(planStatus==='success'?'ok':(planStatus==='nopath'||planStatus==='emergency')?'er':planStatus==='aligning'?'ev':'');
  let col=false;for(const ob of scene.obstacles){if(egoCol(scene.ego,cfg.vehicle,ob)){col=true;break;}}
  const mc=document.getElementById('mCo');mc.textContent=col?'ç¢°æ’!':'æ— ';mc.className='MV '+(col?'er':'ok');
  if(lastParkVal)document.getElementById('mPS').textContent=lastParkVal.score.toFixed(0)+'/100';
}

// â•â•â•â•â•â•â•â•â•â•â• DRAWING â•â•â•â•â•â•â•â•â•â•â•
function draw(){
  const W=canvas.width/dpr,H=canvas.height/dpr;ctx.save();ctx.setTransform(dpr,0,0,dpr,0,0);ctx.clearRect(0,0,W,H);
  drawGrid(W,H);drawRoadLanes();if(showCSpace&&GPU.grid)drawCSpace();drawSlot();drawSensorFOV();
  if(showUSS)drawUSS();
  if(trajectory&&trajectory.length>1)drawTraj();drawObs();drawEgo();drawGoal();
  if(lastParkVal&&planStatus==='success')drawParkResult();
  ctx.restore();
}
function drawGrid(W,H){
  ctx.strokeStyle='#121620';ctx.lineWidth=1;
  const wl=s2w(0,0),wr=s2w(W,0);
  for(let x=Math.floor(wl.x);x<=Math.ceil(wr.x);x++){const s=w2s(x,0);ctx.beginPath();ctx.moveTo(s.x,0);ctx.lineTo(s.x,H);ctx.stroke();}
  const wb=s2w(0,H),wt=s2w(0,0);
  for(let y=Math.floor(wb.y);y<=Math.ceil(wt.y);y++){const s=w2s(0,y);ctx.beginPath();ctx.moveTo(0,s.y);ctx.lineTo(W,s.y);ctx.stroke();}
  ctx.strokeStyle='#1c2230';ctx.lineWidth=1.5;const o=w2s(0,0);
  ctx.beginPath();ctx.moveTo(0,o.y);ctx.lineTo(W,o.y);ctx.stroke();
  ctx.beginPath();ctx.moveTo(o.x,0);ctx.lineTo(o.x,H);ctx.stroke();
}
function drawCSpace(){
  const ey=scene.ego.yaw;let iw=Math.round((((ey%TAU)+TAU)%TAU)/(TAU/GPU.nYaw));
  iw=((iw%GPU.nYaw)+GPU.nYaw)%GPU.nYaw;
  const st=GPU.step,sp=st*cam.scale;if(sp<2)return;
  ctx.save();ctx.globalAlpha=0.12;ctx.fillStyle='#a855f7';
  for(let ix=0;ix<GPU.nX;ix++){const wx=GPU.xMin+ix*st;
    for(let iy=0;iy<GPU.nY;iy++){
      if(GPU.grid[ix*GPU.nY*GPU.nYaw+iy*GPU.nYaw+iw]){
        const s=w2s(wx,GPU.yMin+iy*st);ctx.fillRect(s.x-sp/2,s.y-sp/2,sp,sp);}}}
  ctx.restore();
}

function drawRoadLanes(){
  const r=scene.road;if(!r)return;
  const x0=GPU.xMin,x1=GPU.xMax;
  const yTop=r.yCenter+r.laneWidth,yBot=r.yCenter-r.laneWidth;
  const p0=w2s(x0,yTop),p1=w2s(x1,yBot);
  ctx.save();
  ctx.fillStyle='rgba(148,163,184,.06)';
  ctx.fillRect(p0.x,p0.y,p1.x-p0.x,p1.y-p0.y);
  const b1=w2s(x0,yTop),b2=w2s(x1,yTop),b3=w2s(x0,yBot),b4=w2s(x1,yBot),c1=w2s(x0,r.yCenter),c2=w2s(x1,r.yCenter);
  ctx.strokeStyle='rgba(255,255,255,.35)';ctx.lineWidth=1.8;
  ctx.beginPath();ctx.moveTo(b1.x,b1.y);ctx.lineTo(b2.x,b2.y);ctx.stroke();
  ctx.beginPath();ctx.moveTo(b3.x,b3.y);ctx.lineTo(b4.x,b4.y);ctx.stroke();
  ctx.strokeStyle='rgba(250,204,21,.6)';ctx.lineWidth=1.2;ctx.setLineDash([8,6]);
  ctx.beginPath();ctx.moveTo(c1.x,c1.y);ctx.lineTo(c2.x,c2.y);ctx.stroke();ctx.setLineDash([]);
  ctx.restore();
}

function drawSlot(){
  const poly=scene.slot.poly;if(poly.length<3)return;ctx.save();
  ctx.beginPath();const p0=w2s(poly[0].x,poly[0].y);ctx.moveTo(p0.x,p0.y);
  for(let i=1;i<poly.length;i++){const p=w2s(poly[i].x,poly[i].y);ctx.lineTo(p.x,p.y);}
  ctx.closePath();ctx.fillStyle='rgba(52,211,153,.05)';ctx.fill();
  // Solid parking lines (not dashed - real parking lines)
  ctx.strokeStyle='rgba(255,255,255,.6)';ctx.lineWidth=2;ctx.stroke();
  ctx.fillStyle='#34d399';
  for(const pt of poly){const p=w2s(pt.x,pt.y);ctx.beginPath();ctx.arc(p.x,p.y,2.5,0,TAU);ctx.fill();}
  const cx=poly.reduce((s,p)=>s+p.x,0)/poly.length,cy=poly.reduce((s,p)=>s+p.y,0)/poly.length;
  const cs=w2s(cx,cy);ctx.font='600 9px "JetBrains Mono",monospace';ctx.fillStyle='rgba(52,211,153,.6)';
  ctx.textAlign='center';ctx.fillText('è½¦ä½',cs.x,cs.y+3);ctx.restore();
}
function drawGoal(){
  const g=scene.slot.goal,gs=w2s(g.x,g.y);ctx.save();ctx.translate(gs.x,gs.y);ctx.rotate(-g.yaw);
  const L=cfg.vehicle.length*cam.scale,W=cfg.vehicle.width*cam.scale;
  ctx.strokeStyle='rgba(52,211,153,.3)';ctx.lineWidth=1;ctx.setLineDash([4,3]);
  ctx.strokeRect(-L/2,-W/2,L,W);ctx.setLineDash([]);
  ctx.fillStyle='rgba(52,211,153,.4)';ctx.beginPath();ctx.moveTo(L/2+4,0);ctx.lineTo(L/2-6,-5);ctx.lineTo(L/2-6,5);ctx.closePath();ctx.fill();
  ctx.restore();
}
function drawSensorFOV(){
  const e=scene.ego,es=w2s(e.x,e.y),range=cfg.sensor.lidarRange*cam.scale,fov=deg2rad(cfg.sensor.lidarFov);
  ctx.save();ctx.translate(es.x,es.y);
  ctx.beginPath();ctx.moveTo(0,0);ctx.arc(0,0,range,-(e.yaw+fov/2),-(e.yaw-fov/2));ctx.closePath();
  const gr=ctx.createRadialGradient(0,0,0,0,0,range);
  gr.addColorStop(0,'rgba(56,189,248,.06)');gr.addColorStop(1,'rgba(56,189,248,0)');
  ctx.fillStyle=gr;ctx.fill();ctx.strokeStyle='rgba(56,189,248,.1)';ctx.lineWidth=1;ctx.stroke();ctx.restore();
}
function drawUSS(){
  const e=scene.ego,vp=cfg.vehicle;
  const ussL=getUSSLayout(vp);
  const cosY=Math.cos(e.yaw),sinY=Math.sin(e.yaw);
  const range=cfg.sensor.ussRange*cam.scale;
  ctx.save();
  for(const u of ussL){
    const wx=e.x+cosY*u.x-sinY*u.y;
    const wy=e.y+sinY*u.x+cosY*u.y;
    const ws=w2s(wx,wy);
    const worldAng=e.yaw+u.ang;
    ctx.save();ctx.translate(ws.x,ws.y);
    const a1=-(worldAng+u.fov/2),a2=-(worldAng-u.fov/2);
    ctx.beginPath();ctx.moveTo(0,0);ctx.arc(0,0,range,a1,a2);ctx.closePath();
    ctx.fillStyle='rgba(245,158,11,.04)';ctx.fill();
    ctx.strokeStyle='rgba(245,158,11,.15)';ctx.lineWidth=0.5;ctx.stroke();
    // Sensor dot
    ctx.beginPath();ctx.arc(0,0,2,0,TAU);ctx.fillStyle='rgba(245,158,11,.6)';ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}
function drawTraj(){
  ctx.save();ctx.beginPath();const p0=w2s(trajectory[0].x,trajectory[0].y);ctx.moveTo(p0.x,p0.y);
  for(let i=1;i<trajectory.length;i++){const p=w2s(trajectory[i].x,trajectory[i].y);ctx.lineTo(p.x,p.y);}
  ctx.strokeStyle='rgba(129,140,248,.5)';ctx.lineWidth=2;ctx.stroke();
  const step=Math.max(1,Math.floor(trajectory.length/12));ctx.fillStyle='rgba(129,140,248,.6)';
  for(let i=0;i<trajectory.length;i+=step){
    const pt=trajectory[i],ps=w2s(pt.x,pt.y);ctx.save();ctx.translate(ps.x,ps.y);ctx.rotate(-pt.yaw);
    ctx.beginPath();const sz=3.5;
    if(pt.gear===1){ctx.moveTo(sz,0);ctx.lineTo(-sz,-sz*.6);ctx.lineTo(-sz,sz*.6);}
    else{ctx.moveTo(-sz,0);ctx.lineTo(sz,-sz*.6);ctx.lineTo(sz,sz*.6);}
    ctx.closePath();ctx.fill();ctx.restore();}
  ctx.lineWidth=2.5;
  for(let i=0;i<trajectory.length-1;i++){
    const a=trajectory[i],b=trajectory[i+1];const pa=w2s(a.x,a.y),pb=w2s(b.x,b.y);
    ctx.strokeStyle=a.gear===1?'rgba(56,189,248,.3)':'rgba(248,113,113,.3)';
    ctx.beginPath();ctx.moveTo(pa.x,pa.y);ctx.lineTo(pb.x,pb.y);ctx.stroke();}
  ctx.restore();
}
function drawObs(){
  const pS=new Set(perceivedObs.map(o=>o.id));
  for(const ob of scene.obstacles){
    const ip=pS.has(ob.id),id=!!(ob.vx||ob.vy),os=w2s(ob.x,ob.y);
    ctx.save();ctx.translate(os.x,os.y);ctx.rotate(-(ob.yaw||0));
    if(ob.shape==='circle'){
      const r=(ob.r||0.3)*cam.scale;ctx.beginPath();ctx.arc(0,0,r,0,TAU);
      ctx.fillStyle=id?'rgba(245,158,11,.2)':'rgba(239,68,68,.15)';ctx.fill();
      ctx.strokeStyle=id?'rgba(245,158,11,.6)':'rgba(239,68,68,.5)';ctx.lineWidth=ip?2:1;ctx.stroke();
    }else{
      const w=(ob.w||1)*cam.scale,h=(ob.h||1)*cam.scale;
      ctx.fillStyle=id?'rgba(245,158,11,.15)':'rgba(239,68,68,.12)';ctx.fillRect(-w/2,-h/2,w,h);
      ctx.strokeStyle=id?'rgba(245,158,11,.5)':'rgba(239,68,68,.4)';ctx.lineWidth=ip?2:1;ctx.strokeRect(-w/2,-h/2,w,h);
    }
    if(id){ctx.rotate(ob.yaw||0);const vl=hypot(ob.vx||0,ob.vy||0)*cam.scale*2,va=Math.atan2(-(ob.vy||0),ob.vx||0);
      ctx.rotate(va);ctx.strokeStyle='rgba(245,158,11,.7)';ctx.lineWidth=1.5;
      ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(vl,0);ctx.stroke();
      ctx.fillStyle='rgba(245,158,11,.7)';ctx.beginPath();ctx.moveTo(vl+3,0);ctx.lineTo(vl-3,-2.5);ctx.lineTo(vl-3,2.5);ctx.closePath();ctx.fill();}
    ctx.restore();
    if(ob.kind){ctx.save();ctx.font='500 8px "JetBrains Mono",monospace';ctx.fillStyle='rgba(200,200,200,.35)';ctx.textAlign='center';
      ctx.fillText(ob.kind,os.x,os.y+(ob.shape==='circle'?(ob.r||0.3)*cam.scale+10:((ob.h||1)*cam.scale/2+10)));ctx.restore();}
  }
  if(selected&&selected.type==='ob'){
    const ob=scene.obstacles.find(o=>o.id===selected.id);
    if(ob){const os=w2s(ob.x,ob.y);ctx.save();ctx.strokeStyle='#38bdf8';ctx.lineWidth=2;ctx.setLineDash([4,3]);
      if(ob.shape==='circle'){ctx.beginPath();ctx.arc(os.x,os.y,(ob.r||0.3)*cam.scale+5,0,TAU);ctx.stroke();}
      else{ctx.translate(os.x,os.y);ctx.rotate(-(ob.yaw||0));ctx.strokeRect(-(ob.w||1)*cam.scale/2-3,-(ob.h||1)*cam.scale/2-3,(ob.w||1)*cam.scale+6,(ob.h||1)*cam.scale+6);}
      ctx.setLineDash([]);ctx.restore();}
  }
}
function drawEgo(){
  const e=scene.ego,es=w2s(e.x,e.y),vp=cfg.vehicle,L=vp.length*cam.scale,W=vp.width*cam.scale;
  ctx.save();ctx.translate(es.x,es.y);ctx.rotate(-e.yaw);
  // Body
  const bg=ctx.createLinearGradient(-L/2,0,L/2,0);
  bg.addColorStop(0,'rgba(30,58,95,.8)');bg.addColorStop(1,'rgba(56,189,248,.3)');
  ctx.fillStyle=bg;ctx.beginPath();ctx.roundRect(-L/2,-W/2,L,W,3);ctx.fill();
  ctx.strokeStyle='rgba(56,189,248,.6)';ctx.lineWidth=1.5;ctx.roundRect(-L/2,-W/2,L,W,3);ctx.stroke();
  // Windshield
  ctx.fillStyle='rgba(56,189,248,.12)';ctx.fillRect(L*0.15,-W*0.38,L*0.18,W*0.76);
  // Lights
  ctx.fillStyle='rgba(253,224,71,.5)';ctx.fillRect(L/2-2,-W/2+2,3,5);ctx.fillRect(L/2-2,W/2-7,3,5);
  ctx.fillStyle=e.gear===-1?'rgba(255,255,255,.5)':'rgba(239,68,68,.4)';
  ctx.fillRect(-L/2-1,-W/2+2,3,4);ctx.fillRect(-L/2-1,W/2-6,3,4);
  // Direction
  ctx.fillStyle='rgba(255,255,255,.4)';
  if(e.gear===1){ctx.beginPath();ctx.moveTo(L/2+7,0);ctx.lineTo(L/2-2,-5);ctx.lineTo(L/2-2,5);ctx.closePath();ctx.fill();}
  else if(e.gear===-1){ctx.beginPath();ctx.moveTo(-L/2-7,0);ctx.lineTo(-L/2+2,-5);ctx.lineTo(-L/2+2,5);ctx.closePath();ctx.fill();}
  // Inflation
  const iL=(vp.length+2*vp.inflation)*cam.scale,iW=(vp.width+2*vp.inflation)*cam.scale;
  ctx.strokeStyle='rgba(56,189,248,.1)';ctx.lineWidth=1;ctx.setLineDash([3,3]);ctx.strokeRect(-iL/2,-iW/2,iL,iW);ctx.setLineDash([]);
  ctx.restore();
  if(selected&&selected.type==='ego'){ctx.save();ctx.strokeStyle='#38bdf8';ctx.lineWidth=2;ctx.setLineDash([4,3]);
    ctx.beginPath();ctx.arc(es.x,es.y,Math.max(L,W)/2+7,0,TAU);ctx.stroke();ctx.setLineDash([]);ctx.restore();}
}
function drawParkResult(){
  if(!lastParkVal)return;
  // Draw ego corners and their distance to slot lines
  const corners=getEgoCorners(scene.ego,cfg.vehicle);
  ctx.save();
  for(const c of corners){
    const cs=w2s(c.x,c.y);
    const d=pointToPolyDist(c,scene.slot.poly);
    ctx.beginPath();ctx.arc(cs.x,cs.y,4,0,TAU);
    ctx.fillStyle=d>=0?'rgba(52,211,153,.8)':'rgba(239,68,68,.8)';ctx.fill();
    ctx.font='600 8px "JetBrains Mono",monospace';ctx.fillStyle='#fff';ctx.textAlign='center';
    ctx.fillText((d*100).toFixed(0)+'cm',cs.x,cs.y-8);
  }
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â• EDITOR â•â•â•â•â•â•â•â•â•â•â•
let mode='select',selected=null,dragging=false,dragOff={x:0,y:0},isPanning=false,panLast={x:0,y:0},spaceDown=false;

document.getElementById('toolbar').addEventListener('click',e=>{const b=e.target.closest('button');if(!b)return;
  mode=b.dataset.mode;document.querySelectorAll('#toolbar button').forEach(b=>b.classList.remove('active'));
  b.classList.add('active');document.getElementById('hudM').textContent=mode.toUpperCase();});

function resetSim(){
  running=false;trajectory=null;trajectoryIndex=1;perceivedObs=[];planningObstacles=[];emergencyHold=false;resetAlignState();totalDist=0;gearSwitches=0;lastPlanMs=0;
  avoidState={active:false,goal:null,causeId:null,mode:'none',startT:0};
  avoidTriggerState={id:null,count:0};
  movingObsTracks.clear();
  avoidRangeLatch.clear();
  policyBandit.episode=null;
  planStatus='idle';stepsSincePlan=999;simStepCount=0;lastParkVal=null;
  document.getElementById('btnPlay').textContent='â–¶ å¼€å§‹';
  document.getElementById('btnPlay').classList.remove('running');
  document.getElementById('PS').style.display='none';
  updateMetrics();draw();
}

document.getElementById('btnPlay').addEventListener('click',()=>{running=!running;
  if(running&&scene.stepN===0)selectPolicyForEpisode();
  document.getElementById('btnPlay').textContent=running?'â¸ æš‚åœ':'â–¶ å¼€å§‹';
  document.getElementById('btnPlay').classList.toggle('running',running);});
document.getElementById('btnStep').addEventListener('click',()=>{stepOnce().then(()=>draw());});
document.getElementById('btnReset').addEventListener('click',()=>{scene=mkScene();applySceneMotionProfile();resetSim();});

// â”€â”€ Scene Presets â”€â”€
document.getElementById('btnP1').addEventListener('click',()=>{
  // ä¾§æ–¹ä½åœè½¦ (parallel)
  scene=mkScene();applySceneMotionProfile();resetSim();
});

document.getElementById('btnP2').addEventListener('click',()=>{
  // å‚ç›´æ³Šè½¦
  scene={t:0,stepN:0,road:makeTwoWaySingleLaneRoad(3.6,3.4),ego:{x:-4,y:5.3,yaw:0,v:0,gear:1},
    slot:makeSlot({x:6.5,y:1.0,yaw:deg2rad(-90)},'perpendicular'),
    obstacles:[
      {id:uid(),shape:'rect',x:3.2,y:1.0,yaw:deg2rad(-90),w:4.2,h:1.9,vx:0,vy:0,kind:'åœè½¦'},
      {id:uid(),shape:'rect',x:9.8,y:1.0,yaw:deg2rad(-90),w:4.2,h:1.9,vx:0,vy:0,kind:'åœè½¦'},
      {id:uid(),shape:'circle',x:1,y:6,yaw:0,r:0.3,vx:0.3,vy:-0.1,kind:'è¡Œäºº'},
      {id:uid(),shape:'rect',x:-2,y:-1,yaw:0,w:0.5,h:0.5,vx:0,vy:0,kind:'é”¥æ¡¶'},
      {id:uid(),shape:'rect',x:12,y:-1,yaw:0,w:0.5,h:0.5,vx:0,vy:0,kind:'é”¥æ¡¶'}]};
  applySceneMotionProfile();
  resetSim();
});

document.getElementById('btnP3').addEventListener('click',()=>{
  // æ–œå‘æ³Šè½¦ï¼ˆé±¼éª¨è½¦ä½ï¼‰
  const ang=deg2rad(60);
  scene={t:0,stepN:0,road:makeTwoWaySingleLaneRoad(3.6,3.4),ego:{x:-3,y:5.4,yaw:0,v:0,gear:1},
    slot:makeSlot({x:8.1,y:2.4,yaw:ang},'angled'),
    obstacles:[
      {id:uid(),shape:'rect',x:3.1,y:2.4,yaw:ang,w:4.5,h:1.9,vx:0,vy:0,kind:'åœè½¦'},
      {id:uid(),shape:'rect',x:13.2,y:2.4,yaw:ang,w:4.5,h:1.9,vx:0,vy:0,kind:'åœè½¦'},
      {id:uid(),shape:'circle',x:1.8,y:7.0,yaw:0,r:0.3,vx:0.2,vy:0,kind:'è¡Œäºº'}]};
  applySceneMotionProfile();
  resetSim();
});

document.getElementById('btnP4').addEventListener('click',()=>{
  // å‹åŠ›æµ‹è¯• - å¤šéšœç¢ç‰©ã€åŠ¨æ€
  scene={t:0,stepN:0,road:makeTwoWaySingleLaneRoad(3.6,3.4),ego:{x:-2,y:5.4,yaw:0,v:0,gear:1},
    slot:makeSlot({x:10.5,y:1.0,yaw:0},'parallel'),
    obstacles:[
      {id:uid(),shape:'rect',x:4.5,y:1.0,yaw:0,w:4.5,h:1.8,vx:0,vy:0,kind:'åœè½¦'},
      {id:uid(),shape:'rect',x:17,y:1.0,yaw:0,w:4.5,h:1.8,vx:0,vy:0,kind:'åœè½¦'},
      {id:uid(),shape:'circle',x:5,y:7,yaw:0,r:0.3,vx:0.4,vy:-0.12,kind:'è¡Œäºº'},
      {id:uid(),shape:'circle',x:15,y:8,yaw:0,r:0.3,vx:-0.35,vy:-0.15,kind:'è¡Œäºº'},
      {id:uid(),shape:'circle',x:8,y:5,yaw:0,r:0.3,vx:-0.2,vy:0.25,kind:'è¡Œäºº'},
      {id:uid(),shape:'rect',x:0,y:0,yaw:0,w:0.6,h:0.6,vx:0,vy:0,kind:'é”¥æ¡¶'},
      {id:uid(),shape:'rect',x:20,y:0,yaw:0,w:0.6,h:0.6,vx:0,vy:0,kind:'é”¥æ¡¶'},
      {id:uid(),shape:'rect',x:10,y:8,yaw:0.3,w:2,h:1,vx:0,vy:0,kind:'æŠ¤æ '},
      {id:uid(),shape:'circle',x:-1,y:3,yaw:0,r:0.4,vx:0.65,vy:0,kind:'è‡ªè¡Œè½¦'},
      {id:uid(),shape:'rect',x:12,y:1.9,yaw:PI,w:4.6,h:1.9,vx:-0.35,vy:0,kind:'å¯¹å‘è½¦'}]};
  applySceneMotionProfile();
  resetSim();
});

// Neuroevolution buttons
document.getElementById('btnEvo').addEventListener('click',()=>{
  const btn=document.getElementById('btnEvo');
  if(evoState.running){
    evoState.running=false;
    btn.textContent='âš¡ å¯åŠ¨è®­ç»ƒ';
    return;
  }
  btn.textContent='â–  åœæ­¢è®­ç»ƒ';
  runEvolution().finally(()=>{btn.textContent='âš¡ å¯åŠ¨è®­ç»ƒ';});
});
document.getElementById('btnApply').addEventListener('click',()=>{
  if(!evoState.best)return;
  const b=evoState.best;
  if(b.path&&b.path.length>1){
    trajectory=b.path.map((p,i)=>({x:p.x,y:p.y,yaw:p.yaw,v:p.v,a:p.a,st:p.st,gear:p.gear,t:i*cfg.vehicle.dt}));
    trajectoryIndex=1;
    planStatus='planning';
  }
  alert(`æœ€ä¼˜ç­–ç•¥å·²åº”ç”¨:
ä»£æ•°=${b.generation}
ç½‘ç»œå¾—åˆ†=${b.score.toFixed(1)}
æ³Šè½¦è¯„åˆ†=${b.parkScore.toFixed(0)}/100
ç»ˆç‚¹=(${b.endPose.x.toFixed(2)}, ${b.endPose.y.toFixed(2)})`);
  draw();
});

// Toggles
document.getElementById('tCS').addEventListener('click',function(){showCSpace=!showCSpace;this.classList.toggle('on',showCSpace);draw();});
document.getElementById('tUSS').addEventListener('click',function(){showUSS=!showUSS;this.classList.toggle('on',showUSS);draw();});

// IO
document.getElementById('btnExp').addEventListener('click',()=>{navigator.clipboard.writeText(JSON.stringify(scene,null,2)).catch(()=>{});alert('åœºæ™¯å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');});
document.getElementById('btnImp').addEventListener('click',()=>{const j=prompt('ç²˜è´´åœºæ™¯JSON:');if(!j)return;try{scene=JSON.parse(j);applySceneMotionProfile();resetSim();}catch(e){alert('JSONæ ¼å¼é”™è¯¯');}});


document.getElementById('btnYawL').addEventListener('click',()=>{
  if(scene.stepN>0)return;
  scene.ego.yaw=wrapPi(scene.ego.yaw+deg2rad(15));
  draw();
});
document.getElementById('btnYawR').addEventListener('click',()=>{
  if(scene.stepN>0)return;
  scene.ego.yaw=wrapPi(scene.ego.yaw-deg2rad(15));
  draw();
});

// Keyboard
window.addEventListener('keydown',e=>{if(e.code==='Space'){spaceDown=true;canvas.style.cursor='grab';}});
window.addEventListener('keyup',e=>{if(e.code==='Space'){spaceDown=false;canvas.style.cursor='default';}});
window.addEventListener('keydown',e=>{if(e.key==='Delete'&&selected&&selected.type==='ob'){scene.obstacles=scene.obstacles.filter(o=>o.id!==selected.id);selected=null;draw();}});

// Canvas events
canvas.addEventListener('wheel',e=>{e.preventDefault();cam.scale=clamp(cam.scale*(e.deltaY>0?0.92:1.08),8,250);draw();},{passive:false});
canvas.addEventListener('pointerdown',e=>{
  const r=canvas.getBoundingClientRect(),px=e.clientX-r.left,py=e.clientY-r.top;
  if(spaceDown){isPanning=true;panLast={x:px,y:py};return;}
  const w=s2w(px,py);
  if(mode==='ego'){scene.ego.x=w.x;scene.ego.y=w.y;selected={type:'ego'};draw();return;}
  if(mode==='rect'){const ob={id:uid(),shape:'rect',x:w.x,y:w.y,yaw:0,w:1.8,h:0.8,vx:0,vy:0,kind:'éšœç¢'};scene.obstacles.push(ob);selected={type:'ob',id:ob.id};draw();return;}
  if(mode==='circle'){const ob={id:uid(),shape:'circle',x:w.x,y:w.y,yaw:0,r:0.35,vx:0,vy:0,kind:'éšœç¢'};scene.obstacles.push(ob);selected={type:'ob',id:ob.id};draw();return;}
  if(mode==='dyn'){const ob={id:uid(),shape:'circle',x:w.x,y:w.y,yaw:0,r:0.3,vx:-0.3,vy:0,kind:'è¡Œäºº'};applyMotionProfile(ob);scene.obstacles.push(ob);selected={type:'ob',id:ob.id};draw();return;}
  if(mode==='slot'){scene.slot=makeSlot({x:w.x,y:w.y,yaw:0},'parallel');selected={type:'slot'};draw();return;}
  const hit=pickObj(w.x,w.y);selected=hit;
  if(hit){dragging=true;if(hit.type==='ego')dragOff={x:scene.ego.x-w.x,y:scene.ego.y-w.y};
    else if(hit.type==='ob'){const ob=scene.obstacles.find(o=>o.id===hit.id);if(ob)dragOff={x:ob.x-w.x,y:ob.y-w.y};}
    else if(hit.type==='slot'){const c=pCen(scene.slot.poly);dragOff={x:c.x-w.x,y:c.y-w.y};}}
  draw();
});
canvas.addEventListener('pointermove',e=>{
  const r=canvas.getBoundingClientRect(),px=e.clientX-r.left,py=e.clientY-r.top;
  if(isPanning){cam.ox+=px-panLast.x;cam.oy+=py-panLast.y;panLast={x:px,y:py};draw();return;}
  if(!dragging||!selected)return;const w=s2w(px,py);
  if(selected.type==='ego'){scene.ego.x=w.x+dragOff.x;scene.ego.y=w.y+dragOff.y;}
  else if(selected.type==='ob'){const ob=scene.obstacles.find(o=>o.id===selected.id);if(ob){ob.x=w.x+dragOff.x;ob.y=w.y+dragOff.y;}}
  else if(selected.type==='slot'){const c=pCen(scene.slot.poly);const nx=w.x+dragOff.x,ny=w.y+dragOff.y,dx=nx-c.x,dy=ny-c.y;
    scene.slot.poly=scene.slot.poly.map(p=>({x:p.x+dx,y:p.y+dy}));scene.slot.goal.x+=dx;scene.slot.goal.y+=dy;}
  draw();
});
canvas.addEventListener('pointerup',()=>{dragging=false;isPanning=false;});

function pickObj(x,y){
  const d2=(a,b,c,d)=>(a-c)**2+(b-d)**2;
  if(d2(x,y,scene.ego.x,scene.ego.y)<1.5)return{type:'ego'};
  for(const ob of scene.obstacles){
    if(ob.shape==='circle'){if(d2(x,y,ob.x,ob.y)<(ob.r||0.3)**2+0.3)return{type:'ob',id:ob.id};}
    else{const r=0.5*hypot(ob.w||1,ob.h||1);if(d2(x,y,ob.x,ob.y)<r*r+0.3)return{type:'ob',id:ob.id};}}
  const bb=pBB(scene.slot.poly);if(x>=bb.x0&&x<=bb.x1&&y>=bb.y0&&y<=bb.y1)return{type:'slot'};return null;
}
function pBB(p){let x0=1e9,y0=1e9,x1=-1e9,y1=-1e9;for(const v of p){x0=Math.min(x0,v.x);y0=Math.min(y0,v.y);x1=Math.max(x1,v.x);y1=Math.max(y1,v.y);}return{x0,y0,x1,y1};}
function pCen(p){let x=0,y=0;for(const v of p){x+=v.x;y+=v.y;}return{x:x/p.length,y:y/p.length};}

// â•â•â•â•â•â•â•â•â•â•â• MAIN LOOP â•â•â•â•â•â•â•â•â•â•â•
let lastFrame=0,accum=0;
async function loop(ts){
  requestAnimationFrame(loop);if(!lastFrame)lastFrame=ts;
  const d=(ts-lastFrame)/1000;lastFrame=ts;
  if(running&&planStatus!=='success'&&!planning){
    accum+=d;const st=cfg.vehicle.dt;if(accum>st*4)accum=st*4;
    while(accum>=st){accum-=st;await stepOnce();}
  }
  draw();
}
initGPU().then(()=>{requestAnimationFrame(loop);draw();updateMetrics();});
</script>
</body>
</html>
